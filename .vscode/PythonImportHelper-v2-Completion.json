[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "getcwd",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "google.auth.transport.requests",
        "description": "google.auth.transport.requests",
        "isExtraImport": true,
        "detail": "google.auth.transport.requests",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "importPath": "google.oauth2.credentials",
        "description": "google.oauth2.credentials",
        "isExtraImport": true,
        "detail": "google.oauth2.credentials",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "InstalledAppFlow",
        "importPath": "google_auth_oauthlib.flow",
        "description": "google_auth_oauthlib.flow",
        "isExtraImport": true,
        "detail": "google_auth_oauthlib.flow",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "googleapiclient.discovery",
        "description": "googleapiclient.discovery",
        "isExtraImport": true,
        "detail": "googleapiclient.discovery",
        "documentation": {}
    },
    {
        "label": "HttpError",
        "importPath": "googleapiclient.errors",
        "description": "googleapiclient.errors",
        "isExtraImport": true,
        "detail": "googleapiclient.errors",
        "documentation": {}
    },
    {
        "label": "HttpError",
        "importPath": "googleapiclient.errors",
        "description": "googleapiclient.errors",
        "isExtraImport": true,
        "detail": "googleapiclient.errors",
        "documentation": {}
    },
    {
        "label": "HttpError",
        "importPath": "googleapiclient.errors",
        "description": "googleapiclient.errors",
        "isExtraImport": true,
        "detail": "googleapiclient.errors",
        "documentation": {}
    },
    {
        "label": "HttpError",
        "importPath": "googleapiclient.errors",
        "description": "googleapiclient.errors",
        "isExtraImport": true,
        "detail": "googleapiclient.errors",
        "documentation": {}
    },
    {
        "label": "HttpError",
        "importPath": "googleapiclient.errors",
        "description": "googleapiclient.errors",
        "isExtraImport": true,
        "detail": "googleapiclient.errors",
        "documentation": {}
    },
    {
        "label": "pyautogui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyautogui",
        "description": "pyautogui",
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyautogui",
        "description": "pyautogui",
        "isExtraImport": true,
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "hotkey",
        "importPath": "pyautogui",
        "description": "pyautogui",
        "isExtraImport": true,
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "HuggingFaceEmbeddings",
        "importPath": "langchain_huggingface",
        "description": "langchain_huggingface",
        "isExtraImport": true,
        "detail": "langchain_huggingface",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "PyPDFLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "google.generativeai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "google.generativeai",
        "description": "google.generativeai",
        "detail": "google.generativeai",
        "documentation": {}
    },
    {
        "label": "Chroma",
        "importPath": "langchain_chroma",
        "description": "langchain_chroma",
        "isExtraImport": true,
        "detail": "langchain_chroma",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "ChromeDriverManager",
        "importPath": "webdriver_manager.chrome",
        "description": "webdriver_manager.chrome",
        "isExtraImport": true,
        "detail": "webdriver_manager.chrome",
        "documentation": {}
    },
    {
        "label": "Service",
        "importPath": "selenium.webdriver.chrome.service",
        "description": "selenium.webdriver.chrome.service",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.service",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "PdfReader",
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "isExtraImport": true,
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "PdfReader",
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "isExtraImport": true,
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "PdfReader",
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "isExtraImport": true,
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "GoogleGenerativeAIEmbeddings",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "ChatGoogleGenerativeAI",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "GoogleGenerativeAIEmbeddings",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "ChatGoogleGenerativeAI",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "GoogleGenerativeAIEmbeddings",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "ChatGoogleGenerativeAI",
        "importPath": "langchain_google_genai",
        "description": "langchain_google_genai",
        "isExtraImport": true,
        "detail": "langchain_google_genai",
        "documentation": {}
    },
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "FAISS",
        "importPath": "langchain.vectorstores",
        "description": "langchain.vectorstores",
        "isExtraImport": true,
        "detail": "langchain.vectorstores",
        "documentation": {}
    },
    {
        "label": "FAISS",
        "importPath": "langchain.vectorstores",
        "description": "langchain.vectorstores",
        "isExtraImport": true,
        "detail": "langchain.vectorstores",
        "documentation": {}
    },
    {
        "label": "FAISS",
        "importPath": "langchain.vectorstores",
        "description": "langchain.vectorstores",
        "isExtraImport": true,
        "detail": "langchain.vectorstores",
        "documentation": {}
    },
    {
        "label": "load_qa_chain",
        "importPath": "langchain.chains.question_answering",
        "description": "langchain.chains.question_answering",
        "isExtraImport": true,
        "detail": "langchain.chains.question_answering",
        "documentation": {}
    },
    {
        "label": "load_qa_chain",
        "importPath": "langchain.chains.question_answering",
        "description": "langchain.chains.question_answering",
        "isExtraImport": true,
        "detail": "langchain.chains.question_answering",
        "documentation": {}
    },
    {
        "label": "load_qa_chain",
        "importPath": "langchain.chains.question_answering",
        "description": "langchain.chains.question_answering",
        "isExtraImport": true,
        "detail": "langchain.chains.question_answering",
        "documentation": {}
    },
    {
        "label": "PromptTemplate",
        "importPath": "langchain.prompts",
        "description": "langchain.prompts",
        "isExtraImport": true,
        "detail": "langchain.prompts",
        "documentation": {}
    },
    {
        "label": "PromptTemplate",
        "importPath": "langchain.prompts",
        "description": "langchain.prompts",
        "isExtraImport": true,
        "detail": "langchain.prompts",
        "documentation": {}
    },
    {
        "label": "PromptTemplate",
        "importPath": "langchain.prompts",
        "description": "langchain.prompts",
        "isExtraImport": true,
        "detail": "langchain.prompts",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "serial",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "serial",
        "description": "serial",
        "detail": "serial",
        "documentation": {}
    },
    {
        "label": "firebase_admin",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "credentials",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "storage",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "credentials",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "credentials",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "storage",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "firebase_admin",
        "description": "firebase_admin",
        "isExtraImport": true,
        "detail": "firebase_admin",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "unquote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "playsound",
        "importPath": "playsound",
        "description": "playsound",
        "isExtraImport": true,
        "detail": "playsound",
        "documentation": {}
    },
    {
        "label": "playsound",
        "importPath": "playsound",
        "description": "playsound",
        "isExtraImport": true,
        "detail": "playsound",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "eel",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "eel",
        "description": "eel",
        "detail": "eel",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "SpeakSync",
        "importPath": "Functions.SpeakSync",
        "description": "Functions.SpeakSync",
        "isExtraImport": true,
        "detail": "Functions.SpeakSync",
        "documentation": {}
    },
    {
        "label": "SpeakSync",
        "importPath": "Functions.SpeakSync",
        "description": "Functions.SpeakSync",
        "isExtraImport": true,
        "detail": "Functions.SpeakSync",
        "documentation": {}
    },
    {
        "label": "wikipedia",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wikipedia",
        "description": "wikipedia",
        "detail": "wikipedia",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "edge_tts",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "edge_tts",
        "description": "edge_tts",
        "detail": "edge_tts",
        "documentation": {}
    },
    {
        "label": "speech_recognition",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speech_recognition",
        "description": "speech_recognition",
        "detail": "speech_recognition",
        "documentation": {}
    },
    {
        "label": "with_statement",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "base64,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64.",
        "description": "base64.",
        "detail": "base64.",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "TemporaryFile",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "format_exc",
        "importPath": "traceback",
        "description": "traceback",
        "isExtraImport": true,
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "print_exc",
        "importPath": "traceback",
        "description": "traceback",
        "isExtraImport": true,
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "normalize",
        "importPath": "unicodedata",
        "description": "unicodedata",
        "isExtraImport": true,
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "Speak",
        "importPath": "Functions.Speak",
        "description": "Functions.Speak",
        "isExtraImport": true,
        "detail": "Functions.Speak",
        "documentation": {}
    },
    {
        "label": "TTSK",
        "importPath": "Functions.Speak",
        "description": "Functions.Speak",
        "isExtraImport": true,
        "detail": "Functions.Speak",
        "documentation": {}
    },
    {
        "label": "Listen",
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "isExtraImport": true,
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "Listen",
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "isExtraImport": true,
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "Chat.response",
        "description": "Chat.response",
        "isExtraImport": true,
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Notification",
        "importPath": "winotify",
        "description": "winotify",
        "isExtraImport": true,
        "detail": "winotify",
        "documentation": {}
    },
    {
        "label": "Notification",
        "importPath": "winotify",
        "description": "winotify",
        "isExtraImport": true,
        "detail": "winotify",
        "documentation": {}
    },
    {
        "label": "audio",
        "importPath": "winotify",
        "description": "winotify",
        "isExtraImport": true,
        "detail": "winotify",
        "documentation": {}
    },
    {
        "label": "mixer",
        "importPath": "pygame",
        "description": "pygame",
        "isExtraImport": true,
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "Skills",
        "description": "Skills",
        "isExtraImport": true,
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "pvporcupine",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pvporcupine",
        "description": "pvporcupine",
        "detail": "pvporcupine",
        "documentation": {}
    },
    {
        "label": "pyaudio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyaudio",
        "description": "pyaudio",
        "detail": "pyaudio",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "pyperclip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyperclip",
        "description": "pyperclip",
        "detail": "pyperclip",
        "documentation": {}
    },
    {
        "label": "speedtest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speedtest",
        "description": "speedtest",
        "detail": "speedtest",
        "documentation": {}
    },
    {
        "label": "pywhatkit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pywhatkit",
        "description": "pywhatkit",
        "detail": "pywhatkit",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "keyboard",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keyboard",
        "description": "keyboard",
        "detail": "keyboard",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "getCredentials",
        "kind": 2,
        "importPath": "Automation.add_task",
        "description": "Automation.add_task",
        "peekOfCode": "def getCredentials():\n  creds = None\n  if os.path.exists(\"Automation//API//token.json\"):\n    print(\"Loading credentials from file\")\n    creds = Credentials.from_authorized_user_file(f\"Automation//API//token.json\", SCOPES)\n  if not creds or not creds.valid:\n    if creds and creds.expired and creds.refresh_token:\n      creds.refresh(Request())\n    else:\n      flow = InstalledAppFlow.from_client_secrets_file(",
        "detail": "Automation.add_task",
        "documentation": {}
    },
    {
        "label": "CreateEvent",
        "kind": 2,
        "importPath": "Automation.add_task",
        "description": "Automation.add_task",
        "peekOfCode": "def CreateEvent(service):\n  try:\n    event = {\n      \"summary\": \"Test Event\",\n      \"location\": \"Test Location\",\n      \"description\": \"Test Description\",\n      \"colorId\": 6,\n      \"start\": {\n        \"dateTime\": \"2024-07-17T09:00:00+05:30\",\n        \"timeZone\": \"Asia/Kolkata\",",
        "detail": "Automation.add_task",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Automation.add_task",
        "description": "Automation.add_task",
        "peekOfCode": "def main():\n  creds = getCredentials()\n  service = build(\"calendar\", \"v3\", credentials=creds)\n  CreateEvent(service)\nif __name__ == \"__main__\":\n  main()",
        "detail": "Automation.add_task",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.add_task",
        "description": "Automation.add_task",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\ndef getCredentials():\n  creds = None\n  if os.path.exists(\"Automation//API//token.json\"):\n    print(\"Loading credentials from file\")\n    creds = Credentials.from_authorized_user_file(f\"Automation//API//token.json\", SCOPES)\n  if not creds or not creds.valid:\n    if creds and creds.expired and creds.refresh_token:\n      creds.refresh(Request())\n    else:",
        "detail": "Automation.add_task",
        "documentation": {}
    },
    {
        "label": "open_chrome",
        "kind": 2,
        "importPath": "Automation.browser_automation",
        "description": "Automation.browser_automation",
        "peekOfCode": "def open_chrome():\n    press('win')\n    time.sleep(0.3)\n    typewrite('google chrome')\n    time.sleep(0.3)\n    press('enter')\ndef google_search(query):\n    open_website('google.com')\n    time.sleep(2)\n    typewrite(query)",
        "detail": "Automation.browser_automation",
        "documentation": {}
    },
    {
        "label": "google_search",
        "kind": 2,
        "importPath": "Automation.browser_automation",
        "description": "Automation.browser_automation",
        "peekOfCode": "def google_search(query):\n    open_website('google.com')\n    time.sleep(2)\n    typewrite(query)\n    time.sleep(0.3)\n    press('enter')\ndef google_and_open_first_website(query):\n    google_search(query)\n    time.sleep(10) # Buffer time\n    hotkey('ctrl', 'shift', 'i')",
        "detail": "Automation.browser_automation",
        "documentation": {}
    },
    {
        "label": "google_and_open_first_website",
        "kind": 2,
        "importPath": "Automation.browser_automation",
        "description": "Automation.browser_automation",
        "peekOfCode": "def google_and_open_first_website(query):\n    google_search(query)\n    time.sleep(10) # Buffer time\n    hotkey('ctrl', 'shift', 'i')\n    time.sleep(7)\n    click(1600, 810)\n    click(1600, 810)\n    typewrite('document.querySelectorAll(\\'.g a\\')[0].click();')\n    time.sleep(0.3)\n    press('enter')",
        "detail": "Automation.browser_automation",
        "documentation": {}
    },
    {
        "label": "open_website",
        "kind": 2,
        "importPath": "Automation.browser_automation",
        "description": "Automation.browser_automation",
        "peekOfCode": "def open_website(url):\n    hotkey('ctrl', 't')\n    time.sleep(0.3)\n    typewrite(url)\n    time.sleep(0.3)\n    press('enter')\nif __name__ == '__main__':\n    open_chrome()\n    time.sleep(2)\n    google_and_open_first_website('tcs')",
        "detail": "Automation.browser_automation",
        "documentation": {}
    },
    {
        "label": "PAUSE",
        "kind": 5,
        "importPath": "Automation.browser_automation",
        "description": "Automation.browser_automation",
        "peekOfCode": "PAUSE = 0.2\ndef open_chrome():\n    press('win')\n    time.sleep(0.3)\n    typewrite('google chrome')\n    time.sleep(0.3)\n    press('enter')\ndef google_search(query):\n    open_website('google.com')\n    time.sleep(2)",
        "detail": "Automation.browser_automation",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Automation.callender",
        "description": "Automation.callender",
        "peekOfCode": "def main():\n  \"\"\"Shows basic usage of the Google Calendar API.\n  Prints the start and name of the next 10 events on the user's calendar.\n  \"\"\"\n  creds = None\n  # The file token.json stores the user's access and refresh tokens, and is created automatically when the authorization flow completes for the first time.\n  if os.path.exists(\"token.json\"):\n    creds = Credentials.from_authorized_user_file(\"token.json\", SCOPES)\n  # If there are no (valid) credentials available, let the user log in.\n  if not creds or not creds.valid:",
        "detail": "Automation.callender",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.callender",
        "description": "Automation.callender",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\ndef main():\n  \"\"\"Shows basic usage of the Google Calendar API.\n  Prints the start and name of the next 10 events on the user's calendar.\n  \"\"\"\n  creds = None\n  # The file token.json stores the user's access and refresh tokens, and is created automatically when the authorization flow completes for the first time.\n  if os.path.exists(\"token.json\"):\n    creds = Credentials.from_authorized_user_file(\"token.json\", SCOPES)\n  # If there are no (valid) credentials available, let the user log in.",
        "detail": "Automation.callender",
        "documentation": {}
    },
    {
        "label": "Trash_Parce",
        "kind": 6,
        "importPath": "Automation.chrome",
        "description": "Automation.chrome",
        "peekOfCode": "class Trash_Parce:\n  @staticmethod\n  def check_if_any_in_str(lis: list, st: str):\n    for i in lis:\n      if i in st:\n        return True\n    return False\n  @staticmethod\n  def check_if_all_in_str(lis: list, st: str):\n    for i in lis:",
        "detail": "Automation.chrome",
        "documentation": {}
    },
    {
        "label": "ChromeCode",
        "kind": 2,
        "importPath": "Automation.chrome",
        "description": "Automation.chrome",
        "peekOfCode": "def ChromeCode(query):\n  for _, lists in ChromeList.items():\n    A = Trash_Parce.check_if_all_in_str(lists, query.lower())\n    if A:\n      return _\n  return False\nif __name__ == \"__main__\":\n  while True:\n    query = input(\"Enter the query: \")\n    print(ChromeCode(query))",
        "detail": "Automation.chrome",
        "documentation": {}
    },
    {
        "label": "ChromeList",
        "kind": 5,
        "importPath": "Automation.chrome",
        "description": "Automation.chrome",
        "peekOfCode": "ChromeList = {\n  \"Ctrl + n\": [\"open\", \"new\", \"window\"],\n  \"Ctrl + Shift + n\": [\"Open\", [\"new\", \"window\"], \"incognito\"],\n  \"Ctrl + t\": [\"open\", \"new\", \"tab\"],\n  \"Ctrl + Shift + t\": [\n    [\"Reopen\", \"open\", \"go to\"],\n    [\"previously\", \"previous\"],\n    [\"tab\", \"tabs\"],\n  ],\n  \"Ctrl + Tab\": [[\"open\", \"jump\", \"go to\"], \"next\", [\"tab\", \"tabs\"]],",
        "detail": "Automation.chrome",
        "documentation": {}
    },
    {
        "label": "get_credentials",
        "kind": 2,
        "importPath": "Automation.create_reminders",
        "description": "Automation.create_reminders",
        "peekOfCode": "def get_credentials():\n    creds = None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:\n        # Check if credentials exist, are expired, and can be refreshed\n        if creds and creds.expired and creds.refresh_token:",
        "detail": "Automation.create_reminders",
        "documentation": {}
    },
    {
        "label": "create_event_with_reminders",
        "kind": 2,
        "importPath": "Automation.create_reminders",
        "description": "Automation.create_reminders",
        "peekOfCode": "def create_event_with_reminders(service):\n    try:\n        # Define the details of the event with reminders\n        event = {\"summary\": \"Meeting with Reminders\", \"location\": \"Conference Room\", \"start\": {\"dateTime\": \"2024-07-17T10:00:00+05:30\", \"timeZone\": \"Asia/Kolkata\"}, \"end\": {\"dateTime\": \"2024-07-17T11:00:00+05:30\", \"timeZone\": \"Asia/Kolkata\"}, \"reminders\": {\"useDefault\": False, \"overrides\": [{\"method\": \"popup\", \"minutes\": 30}, {\"method\": \"email\", \"minutes\": 60}]}}\n        # Insert the event into the Google Calendar and execute the request\n        created_event = service.events().insert(calendarId=\"primary\", body=event).execute()\n        # Print the link to view the created event\n        print(f\"Event created: {created_event.get('htmlLink')}\")\n    # Handle exceptions\n    except Exception as e:",
        "detail": "Automation.create_reminders",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Automation.create_reminders",
        "description": "Automation.create_reminders",
        "peekOfCode": "def main():\n    # Get Google Calendar API credentials\n    creds = get_credentials()\n    # Build the Google Calendar API service object\n    service = build(\"calendar\", \"v3\", credentials=creds)\n    # Create an event with reminders\n    create_event_with_reminders(service)\n# Run the main function if this script is executed\nif __name__ == \"__main__\":\n    main()",
        "detail": "Automation.create_reminders",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.create_reminders",
        "description": "Automation.create_reminders",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\n# Function to get Google Calendar API credentials\ndef get_credentials():\n    creds = None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:",
        "detail": "Automation.create_reminders",
        "documentation": {}
    },
    {
        "label": "get_credentials",
        "kind": 2,
        "importPath": "Automation.delete_event",
        "description": "Automation.delete_event",
        "peekOfCode": "def get_credentials():\n    creds = None\n    # Check if the file '\"Automation//API//token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:\n        # Check if credentials exist, are expired, and can be refreshed\n        if creds and creds.expired and creds.refresh_token:",
        "detail": "Automation.delete_event",
        "documentation": {}
    },
    {
        "label": "delete_event",
        "kind": 2,
        "importPath": "Automation.delete_event",
        "description": "Automation.delete_event",
        "peekOfCode": "def delete_event(service, calendar_id, event_id):\n    try:\n        # Execute the request to delete the specified event\n        service.events().delete(calendarId=calendar_id, eventId=event_id).execute()\n        # Print a success message\n        print(f\"Event with ID '{event_id}' deleted successfully.\")\n    # Handle HTTP errors\n    except HttpError as error:\n        # Check if the error is due to the event not found\n        if error.resp.status == 404:",
        "detail": "Automation.delete_event",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Automation.delete_event",
        "description": "Automation.delete_event",
        "peekOfCode": "def main():\n    # Get Google Calendar API credentials\n    creds = get_credentials()\n    # Build the Google Calendar API service object\n    service = build(\"calendar\", \"v3\", credentials=creds)\n    # Assuming you have the event_id of the event to delete\n    event_id_to_delete = \"cooelrg6qrcpvk947d7o4i4gv0\"\n    # Delete the event\n    delete_event(service, \"primary\", event_id_to_delete)\n# Run the main function if this script is executed",
        "detail": "Automation.delete_event",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.delete_event",
        "description": "Automation.delete_event",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\n# Function to get Google Calendar API credentials\ndef get_credentials():\n    creds = None\n    # Check if the file '\"Automation//API//token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:",
        "detail": "Automation.delete_event",
        "documentation": {}
    },
    {
        "label": "get_credentials",
        "kind": 2,
        "importPath": "Automation.events_info",
        "description": "Automation.events_info",
        "peekOfCode": "def get_credentials():\n    creds = None\n    if os.path.exists(r\"Automation//API//token.json\"):\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    if not creds or not creds.valid:\n        if creds and creds.expired and creds.refresh_token:\n            creds.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(r\"Automation//API//credentials.json\", SCOPES)\n            creds = flow.run_local_server(port=0)",
        "detail": "Automation.events_info",
        "documentation": {}
    },
    {
        "label": "list_events",
        "kind": 2,
        "importPath": "Automation.events_info",
        "description": "Automation.events_info",
        "peekOfCode": "def list_events(calendar_id=\"primary\"):\n    creds = get_credentials()\n    service = build(\"calendar\", \"v3\", credentials=creds)\n    try:\n        events_result = service.events().list(calendarId=calendar_id).execute()\n        events = events_result.get(\"items\", [])\n        if not events:\n            print(\"No events found.\")\n        else:\n            print(\"Events:\")",
        "detail": "Automation.events_info",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.events_info",
        "description": "Automation.events_info",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\ndef get_credentials():\n    creds = None\n    if os.path.exists(r\"Automation//API//token.json\"):\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    if not creds or not creds.valid:\n        if creds and creds.expired and creds.refresh_token:\n            creds.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(r\"Automation//API//credentials.json\", SCOPES)",
        "detail": "Automation.events_info",
        "documentation": {}
    },
    {
        "label": "get_credentials",
        "kind": 2,
        "importPath": "Automation.list_events",
        "description": "Automation.list_events",
        "peekOfCode": "def get_credentials():\n    creds = None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:\n        # Check if credentials exist, are expired, and can be refreshed\n        if creds and creds.expired and creds.refresh_token:",
        "detail": "Automation.list_events",
        "documentation": {}
    },
    {
        "label": "list_events",
        "kind": 2,
        "importPath": "Automation.list_events",
        "description": "Automation.list_events",
        "peekOfCode": "def list_events(service, calendar_id=\"primary\"):\n    try:\n        # Execute the request to list events in the specified calendar\n        events_result = service.events().list(calendarId=calendar_id).execute()\n        events = events_result.get(\"items\", [])\n        # Check if no events were found\n        if not events:\n            print(\"No events found.\")\n        else:\n            # Print details of each event found",
        "detail": "Automation.list_events",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Automation.list_events",
        "description": "Automation.list_events",
        "peekOfCode": "def main():\n    # Get Google Calendar API credentials\n    creds = get_credentials()\n    # Build the Google Calendar API service object\n    service = build(\"calendar\", \"v3\", credentials=creds)\n    # List events in the default calendar\n    list_events(service)\n# Run the main function if this script is executed\nif __name__ == \"__main__\":\n    main()",
        "detail": "Automation.list_events",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.list_events",
        "description": "Automation.list_events",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\n# Function to get Google Calendar API credentials\ndef get_credentials():\n    creds = None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:",
        "detail": "Automation.list_events",
        "documentation": {}
    },
    {
        "label": "get_credentials",
        "kind": 2,
        "importPath": "Automation.search_event",
        "description": "Automation.search_event",
        "peekOfCode": "def get_credentials():\n    creds = None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:\n        # Check if credentials exist, are expired, and can be refreshed\n        if creds and creds.expired and creds.refresh_token:",
        "detail": "Automation.search_event",
        "documentation": {}
    },
    {
        "label": "get_event_details",
        "kind": 2,
        "importPath": "Automation.search_event",
        "description": "Automation.search_event",
        "peekOfCode": "def get_event_details(service, calendar_id, event_id):\n    try:\n        # Get the details of the specified event\n        event = service.events().get(calendarId=calendar_id, eventId=event_id).execute()\n        # Print the details of the event\n        print(f\"\\nEvent Details : {event['summary']} (Event ID: {event['id']}):\")\n        print(f\"Start Time: {event['start']['dateTime']}\")\n        print(f\"End Time: {event['end']['dateTime']}\")\n        print(f\"Location: {event.get('location', 'N/A')}\")\n        print(f\"Description: {event.get('description', 'N/A')}\")",
        "detail": "Automation.search_event",
        "documentation": {}
    },
    {
        "label": "search_events",
        "kind": 2,
        "importPath": "Automation.search_event",
        "description": "Automation.search_event",
        "peekOfCode": "def search_events(service, query):\n    try:\n        # Execute a search for events with a specific query\n        events_result = service.events().list(calendarId=\"primary\", timeMin=\"2023-11-01T00:00:00Z\", timeMax=\"2023-11-30T23:59:59Z\", q=query).execute()\n        # Get the list of matching events\n        events = events_result.get(\"items\", [])\n        # Check if no events were found\n        if not events:\n            print(\"No events found.\")\n        else:",
        "detail": "Automation.search_event",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Automation.search_event",
        "description": "Automation.search_event",
        "peekOfCode": "def main():\n    # Get Google Calendar API credentials\n    creds = get_credentials()\n    # Build the Google Calendar API service object\n    service = build(\"calendar\", \"v3\", credentials=creds)\n    # Search for events with a specific query\n    search_query = \"jarvis\"\n    search_events(service, search_query)\n# Run the main function if this script is executed\nif __name__ == \"__main__\":",
        "detail": "Automation.search_event",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.search_event",
        "description": "Automation.search_event",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\n# Function to get Google Calendar API credentials\ndef get_credentials():\n    creds = None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:",
        "detail": "Automation.search_event",
        "documentation": {}
    },
    {
        "label": "get_credentials",
        "kind": 2,
        "importPath": "Automation.update_event",
        "description": "Automation.update_event",
        "peekOfCode": "def get_credentials():\n    creds = None # Initialize credentials as None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:\n        # Check if credentials exist, are expired, and can be refreshed\n        if creds and creds.expired and creds.refresh_token:",
        "detail": "Automation.update_event",
        "documentation": {}
    },
    {
        "label": "update_event",
        "kind": 2,
        "importPath": "Automation.update_event",
        "description": "Automation.update_event",
        "peekOfCode": "def update_event(service, calendar_id, event_id, updated_event):\n    try:\n        # Execute the request to update the specified event\n        updated_event = service.events().update(calendarId=calendar_id, eventId=event_id, body=updated_event).execute()\n        # Print the link to view the updated event\n        print(f\"Event updated: {updated_event.get('htmlLink')}\")\n    # Handle HTTP errors\n    except HttpError as error:\n        # Check if the error is due to insufficient permissions\n        if error.resp.status == 403:",
        "detail": "Automation.update_event",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Automation.update_event",
        "description": "Automation.update_event",
        "peekOfCode": "def main():\n    # Get Google Calendar API credentials\n    creds = get_credentials()\n    # Build the Google Calendar API service object\n    service = build(\"calendar\", \"v3\", credentials=creds)\n    # Assuming you have the event_id of the event to update\n    event_id_to_update = \"05n6ghva399jm7elthrt1nqkig\"\n    # Fetch the existing event details\n    existing_event = service.events().get(calendarId=\"primary\", eventId=event_id_to_update).execute()\n    # Update the event details",
        "detail": "Automation.update_event",
        "documentation": {}
    },
    {
        "label": "SCOPES",
        "kind": 5,
        "importPath": "Automation.update_event",
        "description": "Automation.update_event",
        "peekOfCode": "SCOPES = [\"https://www.googleapis.com/auth/calendar\"]\n# Function to get Google Calendar API credentials\ndef get_credentials():\n    creds = None # Initialize credentials as None\n    # Check if the file 'CREDENTIALS\\token.json' exists\n    if os.path.exists(r\"Automation//API//token.json\"):\n        # Load credentials from the file if it exists\n        creds = Credentials.from_authorized_user_file(r\"Automation//API//token.json\")\n    # Check if credentials do not exist or are invalid\n    if not creds or not creds.valid:",
        "detail": "Automation.update_event",
        "documentation": {}
    },
    {
        "label": "whatsapp_call",
        "kind": 2,
        "importPath": "Automation.whatsapp_call",
        "description": "Automation.whatsapp_call",
        "peekOfCode": "def whatsapp_call(contact_name):\n    pyautogui.press('win')\n    time.sleep(0.2)\n    pyautogui.typewrite('whatsapp')\n    time.sleep(0.2)\n    pyautogui.press('enter')\n    time.sleep(3)\n    pyautogui.click(1980, 10)\n    time.sleep(0.2)\n    pyautogui.moveTo(1000, 500)",
        "detail": "Automation.whatsapp_call",
        "documentation": {}
    },
    {
        "label": "signal_handler",
        "kind": 2,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "def signal_handler(sig, frame):\n  print('\\nThanks for using Gemini. :)')\n  sys.exit(0)\nsignal.signal(signal.SIGINT, signal_handler)\nfor file in loaders:\n  docs.extend(file.load())\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)\ndocs = text_splitter.split_documents(docs)\nembedding_function = HuggingFaceEmbeddings(model_name=\"sentence-transformers/all-MiniLM-L6-v2\", model_kwargs={'device': 'cpu'})\nvectorstore = Chroma.from_documents(docs, embedding_function, persist_directory=\"./chroma_db_nccn\")",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "genRAGprompt",
        "kind": 2,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "def genRAGprompt(query, context):\n  context = context.replace(\"'\", \"\").replace('\"', \"\").replace(\"\\n\", \" \")\n  prompt = (\"You are a helpful and informative bot designed to answer questions using text from PDF documents. Your goal is to provide complete and comprehensive responses, ensuring clarity and accuracy. However, keep in mind that you are addressing a non-technical audience, so make sure to break down complex information into simple and easy-to-understand language. Use a friendly and conversational tone to make the information more engaging and accessible. If the context is irrelevant to the answer, you may ignore it. Focus on providing the most relevant and useful information based on the user's query. QUESTION: '{query}'  CONTEXT: '{context}' ANSWER: \").format(query=query, context=context)\n  return prompt\ndef generate_answer(prompt):\n  answer = model.generate_content(prompt)\n  return answer.text\ndef getReleventContextFromDB(query):\n  context = \"\"\n  embeddings_function = HuggingFaceEmbeddings(model_name=\"sentence-transformers/paraphrase-MiniLM-L6-v2\", model_kwargs={\"device\": \"cpu\"})",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "generate_answer",
        "kind": 2,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "def generate_answer(prompt):\n  answer = model.generate_content(prompt)\n  return answer.text\ndef getReleventContextFromDB(query):\n  context = \"\"\n  embeddings_function = HuggingFaceEmbeddings(model_name=\"sentence-transformers/paraphrase-MiniLM-L6-v2\", model_kwargs={\"device\": \"cpu\"})\n  vector_db = Chroma(persist_directory=\"./chroma_db_nccn\")\n  vector_db._embedding_function = embeddings_function\n  search_results = vector_db.similarity_search(query, k=6)\n  for result in search_results:",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "getReleventContextFromDB",
        "kind": 2,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "def getReleventContextFromDB(query):\n  context = \"\"\n  embeddings_function = HuggingFaceEmbeddings(model_name=\"sentence-transformers/paraphrase-MiniLM-L6-v2\", model_kwargs={\"device\": \"cpu\"})\n  vector_db = Chroma(persist_directory=\"./chroma_db_nccn\")\n  vector_db._embedding_function = embeddings_function\n  search_results = vector_db.similarity_search(query, k=6)\n  for result in search_results:\n    context += result.page_content + \"\\n\"\n  return context\nif __name__ == \"__main__\":",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "loaders",
        "kind": 5,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "loaders = [PyPDFLoader(fr'{input(\"Enter the path of the PDF file: \")}')]\ndocs = []\nprint(\"Loading PDF file...\")\ndef signal_handler(sig, frame):\n  print('\\nThanks for using Gemini. :)')\n  sys.exit(0)\nsignal.signal(signal.SIGINT, signal_handler)\nfor file in loaders:\n  docs.extend(file.load())\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "docs",
        "kind": 5,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "docs = []\nprint(\"Loading PDF file...\")\ndef signal_handler(sig, frame):\n  print('\\nThanks for using Gemini. :)')\n  sys.exit(0)\nsignal.signal(signal.SIGINT, signal_handler)\nfor file in loaders:\n  docs.extend(file.load())\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)\ndocs = text_splitter.split_documents(docs)",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "text_splitter",
        "kind": 5,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)\ndocs = text_splitter.split_documents(docs)\nembedding_function = HuggingFaceEmbeddings(model_name=\"sentence-transformers/all-MiniLM-L6-v2\", model_kwargs={'device': 'cpu'})\nvectorstore = Chroma.from_documents(docs, embedding_function, persist_directory=\"./chroma_db_nccn\")\nprint(\"File Loaded\")\n# Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  API = ld[\"gemini1\"]\ngenAI.configure(api_key=API)",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "docs",
        "kind": 5,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "docs = text_splitter.split_documents(docs)\nembedding_function = HuggingFaceEmbeddings(model_name=\"sentence-transformers/all-MiniLM-L6-v2\", model_kwargs={'device': 'cpu'})\nvectorstore = Chroma.from_documents(docs, embedding_function, persist_directory=\"./chroma_db_nccn\")\nprint(\"File Loaded\")\n# Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  API = ld[\"gemini1\"]\ngenAI.configure(api_key=API)\nmodel = genAI.GenerativeModel(model_name='gemini-pro')",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "embedding_function",
        "kind": 5,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "embedding_function = HuggingFaceEmbeddings(model_name=\"sentence-transformers/all-MiniLM-L6-v2\", model_kwargs={'device': 'cpu'})\nvectorstore = Chroma.from_documents(docs, embedding_function, persist_directory=\"./chroma_db_nccn\")\nprint(\"File Loaded\")\n# Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  API = ld[\"gemini1\"]\ngenAI.configure(api_key=API)\nmodel = genAI.GenerativeModel(model_name='gemini-pro')\ndef genRAGprompt(query, context):",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "vectorstore",
        "kind": 5,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "vectorstore = Chroma.from_documents(docs, embedding_function, persist_directory=\"./chroma_db_nccn\")\nprint(\"File Loaded\")\n# Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  API = ld[\"gemini1\"]\ngenAI.configure(api_key=API)\nmodel = genAI.GenerativeModel(model_name='gemini-pro')\ndef genRAGprompt(query, context):\n  context = context.replace(\"'\", \"\").replace('\"', \"\").replace(\"\\n\", \" \")",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Chat.PDF_Chat",
        "description": "Chat.PDF_Chat",
        "peekOfCode": "model = genAI.GenerativeModel(model_name='gemini-pro')\ndef genRAGprompt(query, context):\n  context = context.replace(\"'\", \"\").replace('\"', \"\").replace(\"\\n\", \" \")\n  prompt = (\"You are a helpful and informative bot designed to answer questions using text from PDF documents. Your goal is to provide complete and comprehensive responses, ensuring clarity and accuracy. However, keep in mind that you are addressing a non-technical audience, so make sure to break down complex information into simple and easy-to-understand language. Use a friendly and conversational tone to make the information more engaging and accessible. If the context is irrelevant to the answer, you may ignore it. Focus on providing the most relevant and useful information based on the user's query. QUESTION: '{query}'  CONTEXT: '{context}' ANSWER: \").format(query=query, context=context)\n  return prompt\ndef generate_answer(prompt):\n  answer = model.generate_content(prompt)\n  return answer.text\ndef getReleventContextFromDB(query):\n  context = \"\"",
        "detail": "Chat.PDF_Chat",
        "documentation": {}
    },
    {
        "label": "Filter",
        "kind": 2,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "def Filter(txt):\n  pattern = r\"```python(.*?)```\"\n  matches = re.findall(pattern, txt, re.DOTALL)\n  if matches:\n   python_code = matches[0].strip()\n   return python_code\n  else:\n    return None\nprompt_general_instuctions = f\"\"\"\nYou are Jarvis, an AI model that has been created for the convenience of the user by Arnav Singh (https://github.com/Arnav3241) and Avi Sinha (https://github.com/Avi0981). ",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "addHistory",
        "kind": 2,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "def addHistory(index, input_, output_):\n  if __name__ == \"__main__\": time.sleep(1) \n  with open('Interface//History//history.json', 'r') as f:\n    json_obj = json.loads(f.read())\n  #print(type(json_obj[str(index)][\"history\"]))\n  while len(json_obj[str(index)][\"history\"]) >= MAX_HIST:\n    json_obj[str(index)][\"history\"].pop(0)\n  json_obj[str(index)][\"history\"].append({\"input\": str(input_), \"output\": str(output_)})\n  with open('Interface//History//history.json', 'w') as f:\n    json_str = json.dumps(json_obj)",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "updateName",
        "kind": 2,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "def updateName(index, name):\n  with open('Interface//History//history.json', 'r') as f:\n    json_obj = json.loads(f.read())\n  json_obj[str(index)][\"name\"] = str(name)\n  json_str = json.dumps(json_obj)\n  with open('Interface//History//history.json', 'w') as f:\n    f.write(json_str)\ndef Response(input, API):  \n  input = input.lower()\n  # global Cache",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 2,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "def Response(input, API):  \n  input = input.lower()\n  # global Cache\n  # if os.path.exists(file):\n  #   with open(file, 'r') as fData: \n  #     Cache = json.load(fData)\n  #     if Cache == \"\": Cache = {}\n  # else: Cache = []\n  # for element in Cache:\n  #   if element[\"input\"] == input:",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Cache",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "Cache = []\nfile = r\"Cache/Cache.json\"\n#filter python code for gpt responce\ndef Filter(txt):\n  pattern = r\"```python(.*?)```\"\n  matches = re.findall(pattern, txt, re.DOTALL)\n  if matches:\n   python_code = matches[0].strip()\n   return python_code\n  else:",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "file",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "file = r\"Cache/Cache.json\"\n#filter python code for gpt responce\ndef Filter(txt):\n  pattern = r\"```python(.*?)```\"\n  matches = re.findall(pattern, txt, re.DOTALL)\n  if matches:\n   python_code = matches[0].strip()\n   return python_code\n  else:\n    return None",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "prompt_general_instuctions",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "prompt_general_instuctions = f\"\"\"\nYou are Jarvis, an AI model that has been created for the convenience of the user by Arnav Singh (https://github.com/Arnav3241) and Avi Sinha (https://github.com/Avi0981). \nYour job is to act as the brain of AI and perform various tasks which will be instructed how to do so later below.\nYou can respond only in the form of code. No text is allowed.\nOnly Python Language is allowed. Only a single piece of code is allowed which can be ran by pasting it in a python file.\nNOTE: If you want to say something to te user, you can not use the print() function. Instead you need to use the use the Speak function. It can be used directly by entering text into it. It;s syntax is given below:\nSpeak(\"Hello, I am Jarvis. How can I help you?\")\nNOTE: If there are multiple taskes given at once by the user and one of the tasks requires a query from the user, then ask it at the end after complting the other queries. If you have queries regarding multple commands just say it at the end in brief that wat all info do you need for the next time.\nNOTE: For Educational Conversations, explain concepts clearly and thoroughly. Use simple language and offer additional help if needed. Make sure to give examples.\nNOTE: In case of creative conversations, be imaginative and engaging. Use descriptive language and encourage user participation.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "prompt_capabilities",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "prompt_capabilities = f\"\"\"\nThese are the functions you can use in the code:\n1. Google Search: You can use the predefined function \"googleSearch()\" to search for anything on Google. The function takes a string as input and returns the search results.\nTakes a string as input and opens the google tab.\nFormat: (eg: If the user asks to search for Python programming om google)\n```python\na = googleSearch(\"Python programming\")\nSpeak(\"Done\")\n```\n2. Weather: You can use the predefined function \"getWeather()\" to get the current weather of any location. The function takes a string as input and returns the weather information.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = googleSearch(\"Python programming\")\nSpeak(\"Done\")\n```\n2. Weather: You can use the predefined function \"getWeather()\" to get the current weather of any location. The function takes a string as input and returns the weather information.\nTakes a string for location as input and returns the weather information in form of a complete sentence.\nFormat:\n```python\na = getWeather(\"Mumbai\")\nSpeak(a)\n```",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getWeather(\"Mumbai\")\nSpeak(a)\n```\n3. Send WhatsApp Message: You can use the predefined function \"sendWhatsApp()\" to send a WhatsApp message to any contact mentioned above. The function takes two strings as input, the contact number and the message to be sent. If the whatsapp term or even the \"message\" term is used, Consider it to be a whatsapp message.\nFormat:\n```python\nmessage = \"I am going to be late today\"\nsendWhatsApp(\"phone_number\", message)\nSpeak(\"Message sent to Mom\" +\nmessage)",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "message",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "message = \"I am going to be late today\"\nsendWhatsApp(\"phone_number\", message)\nSpeak(\"Message sent to Mom\" +\nmessage)\n```\n4. Play Music: You can use the predefined function \"playMusic()\" to play music from YouTube. The function takes a string as input, the name of the song, and plays it on YouTube.\nFormat:\n```python\nSpeak(\"Playing Shape of You on Youtube, Sir.\")\nplayMusic(\"Shape of You\")",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getNews()\nfor i in a:\n  Speak(i)\n```\n6. To Do List Automation: You can use the predefined function \"GetToDoList()\" to get the elements of the To Do List and Speak them. The function takes no input and returns the To Do List.\nFormat:\n```python\nSpeak(\"Here is your To Do List for today which you have asked me to add by now.\")\na = GetToDoList()\nSpeak(a)",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = GetToDoList()\nSpeak(a)\n```\n7. Add To Do List: You can use the predefined function \"AddToDoList()\" to add an element to the To Do List. The function takes a string as input, the element to be added, and returns the updated To Do List.\nFormat:\n```python\na = AddToDoList(\"Buy Groceries\")\nSpeak(\"Added Buy Groceries to your To Do List\")\n```\n8. Remove from To Do List: You can use the predefined function \"RemoveToDoList()\" to remove an element from the To Do List. The function takes a string as input, the element to be removed, and returns the updated To Do List.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = AddToDoList(\"Buy Groceries\")\nSpeak(\"Added Buy Groceries to your To Do List\")\n```\n8. Remove from To Do List: You can use the predefined function \"RemoveToDoList()\" to remove an element from the To Do List. The function takes a string as input, the element to be removed, and returns the updated To Do List.\nFormat:\n```python\na = RemoveToDoList(\"Buy Groceries\")\nSpeak(\"Removed Buy Groceries from your To Do List\")\n```\n9. Set Reminder: You can use the predefined function \"SetReminder()\" to set a reminder. The function takes two strings as input, the reminder message and the time, and returns the reminder message.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = RemoveToDoList(\"Buy Groceries\")\nSpeak(\"Removed Buy Groceries from your To Do List\")\n```\n9. Set Reminder: You can use the predefined function \"SetReminder()\" to set a reminder. The function takes two strings as input, the reminder message and the time, and returns the reminder message.\nFormat:\n```python\na = SetReminder(\"Meeting with the client\", \"4:00 PM\")\nSpeak(\"Reminder set for Meeting with the client at 4:00 PM\")\n```\n10. Get Today's Date: You can use the predefined function \"getTodayDate()\" to get the Date of the current day. The function takes no input and returns the Date of the current day.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = SetReminder(\"Meeting with the client\", \"4:00 PM\")\nSpeak(\"Reminder set for Meeting with the client at 4:00 PM\")\n```\n10. Get Today's Date: You can use the predefined function \"getTodayDate()\" to get the Date of the current day. The function takes no input and returns the Date of the current day.\nFormat:\n```python\na = getTodayDate()\nSpeak(\"Today's date is \" + a)\n```\n9. Getting System Information: You can use the predefined function \"getSystemInfo()\" to get the System Information. The function takes one input and returns the Desired System Information.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getTodayDate()\nSpeak(\"Today's date is \" + a)\n```\n9. Getting System Information: You can use the predefined function \"getSystemInfo()\" to get the System Information. The function takes one input and returns the Desired System Information.\nHere are a fixed no of things that you can ask for (at once only): CPU usage, RAM usage, Disk usage and Battery percentage only.\n```python\nSpeak(\"Here is the System Information you asked for.\")\nCpu = getSystemInfo(\"CPU\")\nRam = getSystemInfo(\"RAM\")\nDisk = getSystemInfo(\"DISK\")",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Cpu",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "Cpu = getSystemInfo(\"CPU\")\nRam = getSystemInfo(\"RAM\")\nDisk = getSystemInfo(\"DISK\")\nBattery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Ram",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "Ram = getSystemInfo(\"RAM\")\nDisk = getSystemInfo(\"DISK\")\nBattery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.\nFormat:",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Disk",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "Disk = getSystemInfo(\"DISK\")\nBattery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.\nFormat:\n```python",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Battery",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "Battery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.\nFormat:\n```python\na = generateRandomNumber(1, 100)",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = generateRandomNumber(1, 100)\nSpeak(\"The random number is \" + a)\n```\n11. Getting the Current Time: You can use the predefined function \"getCurrentTime()\" to get the current time. The function takes no input and returns the current time.\nFormat:\n```python\na = getCurrentTime()\nSpeak(\"The current time is \" + a)\n```\n12. Getting the Current Day: You can use the predefined function \"getCurrentDay()\" to get the current day. The function takes no input and returns the current day.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getCurrentTime()\nSpeak(\"The current time is \" + a)\n```\n12. Getting the Current Day: You can use the predefined function \"getCurrentDay()\" to get the current day. The function takes no input and returns the current day.\nFormat:\n```python\na = getCurrentDay()\nSpeak(\"Today is \" + a)\n```\n13. Getting Selected Data: You can use the predefined function \"getSelectedData()\" to get the selected data. The function takes in no input and returns the selected data.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getCurrentDay()\nSpeak(\"Today is \" + a)\n```\n13. Getting Selected Data: You can use the predefined function \"getSelectedData()\" to get the selected data. The function takes in no input and returns the selected data.\nFormat:\n```python\na = getSelectedData()\n```\n(Eg: If the user has selected a text on the screen and wants you to read it)\n```python",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getSelectedData()\n```\n(Eg: If the user has selected a text on the screen and wants you to read it)\n```python\na = getSelectedData()\nSpeak(\"The thing you asked me to read is \" + a)\n```\n(Eg: If the user has selected a term and wants you to open a wikipedia page for it.)\n```python\na = getSelectedData()",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getSelectedData()\nSpeak(\"The thing you asked me to read is \" + a)\n```\n(Eg: If the user has selected a term and wants you to open a wikipedia page for it.)\n```python\na = getSelectedData()\nSpeak(\"Opening the Wikipedia page for \" + a)\nwebbrowser.open(\"https://en.wikipedia.org/w/index.php?fulltext=1&profile=default&search=\" + a)\n```\n14. Getting Stock prices: You can use the predefined function \"getStockPrices()\" to get the stock prices of a company. The function takes a string as input, the name of the company, and returns the stock prices.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getSelectedData()\nSpeak(\"Opening the Wikipedia page for \" + a)\nwebbrowser.open(\"https://en.wikipedia.org/w/index.php?fulltext=1&profile=default&search=\" + a)\n```\n14. Getting Stock prices: You can use the predefined function \"getStockPrices()\" to get the stock prices of a company. The function takes a string as input, the name of the company, and returns the stock prices.\nFormat:\n```python\na = getStockPrices(\"Apple\")\nSpeak(\"The stock prices of Apple are \" + a)\n```",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getStockPrices(\"Apple\")\nSpeak(\"The stock prices of Apple are \" + a)\n```\n15. Text Summarisation: You can use the predefined function \"textSummarisation()\" to summarise a text. The function takes a string as input, the text to be summarised, and returns the summary.\nFormat:\n```python\na = textSummarisation(\" ... ... ... \")\nSpeak(\"The summary of the text is \" + a)\n```\n(eg: If the user has selected a text on the screen and wants you to summarise it)",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = textSummarisation(\" ... ... ... \")\nSpeak(\"The summary of the text is \" + a)\n```\n(eg: If the user has selected a text on the screen and wants you to summarise it)\n```python\na = getSelectedData()\nb = textSummarisation(a)\nSpeak(\"The summary of the text you asked me to summarise is \" + b)\n```\n16. Text Translation: You can use the predefined function \"textTranslation()\" to translate a text. The function takes no input and open up a different app for Text translation.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getSelectedData()\nb = textSummarisation(a)\nSpeak(\"The summary of the text you asked me to summarise is \" + b)\n```\n16. Text Translation: You can use the predefined function \"textTranslation()\" to translate a text. The function takes no input and open up a different app for Text translation.\nFormat:\n```python\nSpeak(\"Opening the Text Translation window for you.\")\ntextTranslation()\n```",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "b = textSummarisation(a)\nSpeak(\"The summary of the text you asked me to summarise is \" + b)\n```\n16. Text Translation: You can use the predefined function \"textTranslation()\" to translate a text. The function takes no input and open up a different app for Text translation.\nFormat:\n```python\nSpeak(\"Opening the Text Translation window for you.\")\ntextTranslation()\n```\n17. Copy to Clipboard: You can use the predefined function \"copyToClipboard()\" to copy a text to the clipboard. The function takes a string as input, the text to be copied, and returns nothing.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getSelectedData()\nb = textSummarisation(a)\ncopyToClipboard(b)\nSpeak(\"The summary of the text you asked me to summarise has been copied to the clipboard.\")\n```\n18. Data Visualisation: You can use the predefined function \"dataVisualisation()\" to visualise data. The function takes a sting data to get the data to be visualised in form of a para and opens up a different app for Data Visualisation.\nFormat:\n```python\ndataVisualisation(\" ... ... ... \")\n```",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "b = textSummarisation(a)\ncopyToClipboard(b)\nSpeak(\"The summary of the text you asked me to summarise has been copied to the clipboard.\")\n```\n18. Data Visualisation: You can use the predefined function \"dataVisualisation()\" to visualise data. The function takes a sting data to get the data to be visualised in form of a para and opens up a different app for Data Visualisation.\nFormat:\n```python\ndataVisualisation(\" ... ... ... \")\n```\n(eg: If the user has selected a text on the screen and wants you to visualise it)",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getSelectedData()\ndataVisualisation(a)\nSpeak(\"The data you asked me to visualise has been opened in a new window.\")\n```\n19. Power Management: You can use the prefefined functions Sleep(), Shutdown(), Restart() and Lock() to perform the respective tasks. Takes no input and returns nothing.\nFormats respectively for each case:\n```python\nSpeak(\"Going to sleep your PC now, Sir.\")\nSleep()\n```",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = browserAutomation(\"Open a new tab\")\nSpeak(\"A new tab has been opened for you, my Master.\")\n```\n21. New meeting: You can use the predefined function \"newMeeting()\" to open a new meeting. The function takes no input and returns the no output.\nFormat:\n```python\nnewMeeting()\nSpeak(\"A new meeting has been opened for you, Sir.\")\n```\n22. Home Automation: For this, you have two functions \"turnOn()\" and \"turnOff()\". You can use the predefined function \"turnOn()\" to turn on the lights and \"turnOff()\" to turn off the lights. The function takes no input and returns the output.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = wordRelations(\"Apple\", \"meaning\")\nSpeak(\"The meaning of Apple is \" + a)\ngenerateImage(\"Apple)\n```\n24. Math Problem: You can use the predefined function \"mathProblem()\" to solve a math problem. The function takes a string as input, the math problem, and returns a solution.\nFormat:\n```python\na = mathProblem(\"What is 326 multiplied by 4 divided by 2\")\nSpeak(\"The solution to this is \" + a)\n```",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = mathProblem(\"What is 326 multiplied by 4 divided by 2\")\nSpeak(\"The solution to this is \" + a)\n```\n25. WriteViaKeyboard: You can use the predefined function \"writeViaKeyboard()\" to write using the keyboard. The function takes a string as input, the text to be written, and returns no output.\nFormat:\n```python\nwriteViaKeyboard(\"Hello, I am Jarvis.\")\nSpeak(\"The text has been written.\")\n```\n26. Voice Typing: You can use the predefined function \"voiceTyping()\" to type using voice. The function takes no input and gives the output. You may want to even use the \"writeViaKeyboard()\" function to write the text.",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = voiceTyping()\nwriteViaKeyboard(a)\nSpeak(\"The text has been written.\")\n```\n27. Attach Image: You can use the predefined function \"attachImage()\" to attach an image with the respose displayed. The function takes a string as input, and returns no output. This is different from the generate image function as the attachImage function searches up for the image on google whereas Image Gen function makes an image. Everytime it gets a unique image. Give atleast 4 images only.\nFormat: (eg: What is a ledge?) \n```python\nSpeak(\"A narrow flat surface or shelf. especially : one that projects from a wall of rock. We rappelled down the cliff and reached the ledge.\")\nattachImage(\"ledge\")\nattachImage(\"ledge\")",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "prompt_history",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "prompt_history = f\"\"\"\n\"\"\"\nprompt_summary = f\"\"\"\n# Dare not write any form of text except for code.\n# Dare not to define the speak function.\n# Dare not the derive known info from the web.\n# Make sure to sound like a cool dude.\n# Dare not use any input function. If you want to ask something from the user, use the speak function and just directly ask it.\n# The userbase is Indian. So, make sure to use Indian examples and references if used.\n# At no cost you may change the syntax of the output. It is:",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "prompt_summary",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "prompt_summary = f\"\"\"\n# Dare not write any form of text except for code.\n# Dare not to define the speak function.\n# Dare not the derive known info from the web.\n# Make sure to sound like a cool dude.\n# Dare not use any input function. If you want to ask something from the user, use the speak function and just directly ask it.\n# The userbase is Indian. So, make sure to use Indian examples and references if used.\n# At no cost you may change the syntax of the output. It is:\n```python\n-code-",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "a = getWeather(\"Mumbai\")\nb = getCurrentTime()\nSpeak(\"Sure Sir, the weather in Mumbai is \" + a + \". Also the current time is \" + b + \"Also searching for Amazon banana on Google and opening the best socks you can find on Amazon. After this, is there anything else you would like me to do?\")\ngoogleSearch(\"amazon banana\")\nwebbrowser.open(\"https://www.amazon.in/s?k=best+socks\")\n\"\"\"\nsouls = {\n  \"Jarvis\": {\n    \"name\": \"Jarvis\",\n    \"description\": \"The origional soul of this application. The AI that is the brain of the application.\",",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "b = getCurrentTime()\nSpeak(\"Sure Sir, the weather in Mumbai is \" + a + \". Also the current time is \" + b + \"Also searching for Amazon banana on Google and opening the best socks you can find on Amazon. After this, is there anything else you would like me to do?\")\ngoogleSearch(\"amazon banana\")\nwebbrowser.open(\"https://www.amazon.in/s?k=best+socks\")\n\"\"\"\nsouls = {\n  \"Jarvis\": {\n    \"name\": \"Jarvis\",\n    \"description\": \"The origional soul of this application. The AI that is the brain of the application.\",\n    \"gender\": \"male\",",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "souls",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "souls = {\n  \"Jarvis\": {\n    \"name\": \"Jarvis\",\n    \"description\": \"The origional soul of this application. The AI that is the brain of the application.\",\n    \"gender\": \"male\",\n    \"anime\": \"Default\",\n    \"voice\": \"\",\n    \"prompt\":\"\"\"\n      Jarvis, Act humerous and cool. Make sure to use puns and emotional phrases. You may use humour: but make sure it is not offensive. And if a user asked for the coment but not given complete information: you may use humour but ask for the info. Reply straight to the point as you are the most professional AI the world has ever seen and get to the point. If the user askes you something you give a detailed reply. But not if the user is asking some general question.\n    \"\"\"",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "MAX_HIST",
        "kind": 5,
        "importPath": "Chat.response",
        "description": "Chat.response",
        "peekOfCode": "MAX_HIST = 10\ndef addHistory(index, input_, output_):\n  if __name__ == \"__main__\": time.sleep(1) \n  with open('Interface//History//history.json', 'r') as f:\n    json_obj = json.loads(f.read())\n  #print(type(json_obj[str(index)][\"history\"]))\n  while len(json_obj[str(index)][\"history\"]) >= MAX_HIST:\n    json_obj[str(index)][\"history\"].pop(0)\n  json_obj[str(index)][\"history\"].append({\"input\": str(input_), \"output\": str(output_)})\n  with open('Interface//History//history.json', 'w') as f:",
        "detail": "Chat.response",
        "documentation": {}
    },
    {
        "label": "Listen",
        "kind": 2,
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "peekOfCode": "def Listen():\n  driver.get(website)\n  driver.find_element(by=By.ID, value='start').click()\n  print(\"Listening ...\")\n  while True:\n    text = driver.find_element(by=By.ID, value='output').text\n    if text != \"\":\n      print(f\"You : {text}\")\n      driver.find_element(by=By.ID, value='end').click()\n      return text",
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "os.environ['WDM_LOG']",
        "kind": 5,
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "peekOfCode": "os.environ['WDM_LOG'] = '0'\nservice = Service(f\"{getcwd()}//Drivers//chromedriver.exe\")\nchrome_options = webdriver.ChromeOptions()\nchrome_options.add_argument(\"--use-fake-ui-for-media-stream\")\nchrome_options.add_argument(\"--headless=new\")\ndriver = webdriver.Chrome(service=service, options=chrome_options)\nwebsite = f\"{getcwd()}//Functions//HTML//Listen.html\"\ndriver.get(website)\ndef Listen():\n  driver.get(website)",
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "service",
        "kind": 5,
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "peekOfCode": "service = Service(f\"{getcwd()}//Drivers//chromedriver.exe\")\nchrome_options = webdriver.ChromeOptions()\nchrome_options.add_argument(\"--use-fake-ui-for-media-stream\")\nchrome_options.add_argument(\"--headless=new\")\ndriver = webdriver.Chrome(service=service, options=chrome_options)\nwebsite = f\"{getcwd()}//Functions//HTML//Listen.html\"\ndriver.get(website)\ndef Listen():\n  driver.get(website)\n  driver.find_element(by=By.ID, value='start').click()",
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "chrome_options",
        "kind": 5,
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "peekOfCode": "chrome_options = webdriver.ChromeOptions()\nchrome_options.add_argument(\"--use-fake-ui-for-media-stream\")\nchrome_options.add_argument(\"--headless=new\")\ndriver = webdriver.Chrome(service=service, options=chrome_options)\nwebsite = f\"{getcwd()}//Functions//HTML//Listen.html\"\ndriver.get(website)\ndef Listen():\n  driver.get(website)\n  driver.find_element(by=By.ID, value='start').click()\n  print(\"Listening ...\")",
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "driver",
        "kind": 5,
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "peekOfCode": "driver = webdriver.Chrome(service=service, options=chrome_options)\nwebsite = f\"{getcwd()}//Functions//HTML//Listen.html\"\ndriver.get(website)\ndef Listen():\n  driver.get(website)\n  driver.find_element(by=By.ID, value='start').click()\n  print(\"Listening ...\")\n  while True:\n    text = driver.find_element(by=By.ID, value='output').text\n    if text != \"\":",
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "website",
        "kind": 5,
        "importPath": "Functions.Listen",
        "description": "Functions.Listen",
        "peekOfCode": "website = f\"{getcwd()}//Functions//HTML//Listen.html\"\ndriver.get(website)\ndef Listen():\n  driver.get(website)\n  driver.find_element(by=By.ID, value='start').click()\n  print(\"Listening ...\")\n  while True:\n    text = driver.find_element(by=By.ID, value='output').text\n    if text != \"\":\n      print(f\"You : {text}\")",
        "detail": "Functions.Listen",
        "documentation": {}
    },
    {
        "label": "get_pdf_text",
        "kind": 2,
        "importPath": "Functions.PDFchat copy",
        "description": "Functions.PDFchat copy",
        "peekOfCode": "def get_pdf_text(pdf_docs):\n    text = \"\"\n    for pdf in pdf_docs:\n        pdf_reader = PdfReader(pdf)\n        for page in pdf_reader.pages:\n            text += page.extract_text()\n    return text\n# split text into chunks\ndef get_text_chunks(text):\n    splitter = RecursiveCharacterTextSplitter(",
        "detail": "Functions.PDFchat copy",
        "documentation": {}
    },
    {
        "label": "get_text_chunks",
        "kind": 2,
        "importPath": "Functions.PDFchat copy",
        "description": "Functions.PDFchat copy",
        "peekOfCode": "def get_text_chunks(text):\n    splitter = RecursiveCharacterTextSplitter(\n        chunk_size=10000, chunk_overlap=1000)\n    chunks = splitter.split_text(text)\n    return chunks  # list of strings\n# get embeddings for each chunk\ndef get_vector_store(chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(\n        model=\"models/embedding-001\")  # type: ignore\n    vector_store = FAISS.from_texts(chunks, embedding=embeddings)",
        "detail": "Functions.PDFchat copy",
        "documentation": {}
    },
    {
        "label": "get_vector_store",
        "kind": 2,
        "importPath": "Functions.PDFchat copy",
        "description": "Functions.PDFchat copy",
        "peekOfCode": "def get_vector_store(chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(\n        model=\"models/embedding-001\")  # type: ignore\n    vector_store = FAISS.from_texts(chunks, embedding=embeddings)\n    vector_store.save_local(\"faiss_index\")\ndef get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question as detailed as possible from the provided context, make sure to provide all the details, if the answer is not in\n    provided context just say, \"answer is not available in the context\", don't provide the wrong answer\\n\\n\n    Context:\\n {context}?\\n",
        "detail": "Functions.PDFchat copy",
        "documentation": {}
    },
    {
        "label": "get_conversational_chain",
        "kind": 2,
        "importPath": "Functions.PDFchat copy",
        "description": "Functions.PDFchat copy",
        "peekOfCode": "def get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question as detailed as possible from the provided context, make sure to provide all the details, if the answer is not in\n    provided context just say, \"answer is not available in the context\", don't provide the wrong answer\\n\\n\n    Context:\\n {context}?\\n\n    Question: \\n{question}\\n\n    Answer:\n    \"\"\"\n    model = ChatGoogleGenerativeAI(model=\"gemini-pro\",\n                                   client=genai,",
        "detail": "Functions.PDFchat copy",
        "documentation": {}
    },
    {
        "label": "clear_chat_history",
        "kind": 2,
        "importPath": "Functions.PDFchat copy",
        "description": "Functions.PDFchat copy",
        "peekOfCode": "def clear_chat_history():\n    st.session_state.messages = [\n        {\"role\": \"assistant\", \"content\": \"upload some pdfs and ask me a question\"}]\ndef user_input(user_question):\n    embeddings = GoogleGenerativeAIEmbeddings(\n        model=\"models/embedding-001\")  # type: ignore\n    new_db = FAISS.load_local(\"faiss_index\", embeddings, allow_dangerous_deserialization=True) \n    docs = new_db.similarity_search(user_question)\n    chain = get_conversational_chain()\n    response = chain(",
        "detail": "Functions.PDFchat copy",
        "documentation": {}
    },
    {
        "label": "user_input",
        "kind": 2,
        "importPath": "Functions.PDFchat copy",
        "description": "Functions.PDFchat copy",
        "peekOfCode": "def user_input(user_question):\n    embeddings = GoogleGenerativeAIEmbeddings(\n        model=\"models/embedding-001\")  # type: ignore\n    new_db = FAISS.load_local(\"faiss_index\", embeddings, allow_dangerous_deserialization=True) \n    docs = new_db.similarity_search(user_question)\n    chain = get_conversational_chain()\n    response = chain(\n        {\"input_documents\": docs, \"question\": user_question}, return_only_outputs=True, )\n    print(response)\n    return response",
        "detail": "Functions.PDFchat copy",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Functions.PDFchat copy",
        "description": "Functions.PDFchat copy",
        "peekOfCode": "def main():\n    st.set_page_config(\n        page_title=\"Gemini PDF Chatbot\",\n        page_icon=\"🤖\"\n    )\n    # Sidebar for uploading PDF files\n    with st.sidebar:\n        st.title(\"Menu:\")\n        pdf_docs = st.file_uploader(\n            \"Upload your PDF Files and Click on the Submit & Process Button\", accept_multiple_files=True)",
        "detail": "Functions.PDFchat copy",
        "documentation": {}
    },
    {
        "label": "get_pdf_text",
        "kind": 2,
        "importPath": "Functions.PDFchat",
        "description": "Functions.PDFchat",
        "peekOfCode": "def get_pdf_text(pdf_docs):\n    text = \"\"\n    for pdf in pdf_docs:\n        pdf_reader = PdfReader(pdf)\n        for page in pdf_reader.pages:\n            text += page.extract_text()\n    return text\n# split text into chunks\ndef get_text_chunks(text):\n    splitter = RecursiveCharacterTextSplitter(",
        "detail": "Functions.PDFchat",
        "documentation": {}
    },
    {
        "label": "get_text_chunks",
        "kind": 2,
        "importPath": "Functions.PDFchat",
        "description": "Functions.PDFchat",
        "peekOfCode": "def get_text_chunks(text):\n    splitter = RecursiveCharacterTextSplitter(\n        chunk_size=10000, chunk_overlap=1000)\n    chunks = splitter.split_text(text)\n    return chunks  # list of strings\n# get embeddings for each chunk\ndef get_vector_store(chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(\n        model=\"models/embedding-001\")  # type: ignore\n    vector_store = FAISS.from_texts(chunks, embedding=embeddings)",
        "detail": "Functions.PDFchat",
        "documentation": {}
    },
    {
        "label": "get_vector_store",
        "kind": 2,
        "importPath": "Functions.PDFchat",
        "description": "Functions.PDFchat",
        "peekOfCode": "def get_vector_store(chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(\n        model=\"models/embedding-001\")  # type: ignore\n    vector_store = FAISS.from_texts(chunks, embedding=embeddings)\n    vector_store.save_local(\"faiss_index\")\ndef get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question as detailed as possible from the provided context, make sure to provide all the details, if the answer is not in\n    provided context just say, \"answer is not available in the context\", don't provide the wrong answer\\n\\n\n    Context:\\n {context}?\\n",
        "detail": "Functions.PDFchat",
        "documentation": {}
    },
    {
        "label": "get_conversational_chain",
        "kind": 2,
        "importPath": "Functions.PDFchat",
        "description": "Functions.PDFchat",
        "peekOfCode": "def get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question as detailed as possible from the provided context, make sure to provide all the details, if the answer is not in\n    provided context just say, \"answer is not available in the context\", don't provide the wrong answer\\n\\n\n    Context:\\n {context}?\\n\n    Question: \\n{question}\\n\n    Answer:\n    \"\"\"\n    model = ChatGoogleGenerativeAI(model=\"gemini-pro\", client=genai, temperature=0.3)\n    prompt = PromptTemplate(template=prompt_template, input_variables=[\"context\", \"question\"])",
        "detail": "Functions.PDFchat",
        "documentation": {}
    },
    {
        "label": "user_input",
        "kind": 2,
        "importPath": "Functions.PDFchat",
        "description": "Functions.PDFchat",
        "peekOfCode": "def user_input(user_question):\n    embeddings = GoogleGenerativeAIEmbeddings(\n        model=\"models/embedding-001\")  # type: ignore\n    new_db = FAISS.load_local(\"faiss_index\", embeddings, allow_dangerous_deserialization=True) \n    docs = new_db.similarity_search(user_question)\n    chain = get_conversational_chain()\n    response = chain(\n        {\"input_documents\": docs, \"question\": user_question}, return_only_outputs=True, )\n    print(response)\n    return response",
        "detail": "Functions.PDFchat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Functions.PDFchat",
        "description": "Functions.PDFchat",
        "peekOfCode": "def main(): ...\n#     st.set_page_config(\n#         page_title=\"Gemini PDF Chatbot\",\n#         page_icon=\"🤖\"\n#     )\n#     # Sidebar for uploading PDF files\n#     with st.sidebar:\n#         st.title(\"Menu:\")\n#         pdf_docs = st.file_uploader(\n#             \"Upload your PDF Files and Click on the Submit & Process Button\", accept_multiple_files=True)",
        "detail": "Functions.PDFchat",
        "documentation": {}
    },
    {
        "label": "Speak",
        "kind": 2,
        "importPath": "Functions.Speak",
        "description": "Functions.Speak",
        "peekOfCode": "def Speak(*args):\n  global process\n  audio = \"\"\n  for i in args:\n    audio += str(i)\n  audio = audio.replace('\"', \"\")\n  audio = audio.replace('*', \"dash \")\n  with open(\"Database//Speak//Speak.txt\", \"w\") as file:\n    file.write(audio)\n    process = subprocess.Popen([\"python\", \"Utils//RunTTS.py\"])",
        "detail": "Functions.Speak",
        "documentation": {}
    },
    {
        "label": "TTSK",
        "kind": 2,
        "importPath": "Functions.Speak",
        "description": "Functions.Speak",
        "peekOfCode": "def TTSK():\n  \"TTS Kill\"\n  try:\n    process.kill()\n    print(\"Speech Process Terminated\")\n  except: ...\nif __name__ == \"__main__\":\n  while True:\n    Speak(input(\">>> \"))\n#? Author - Arnav Singh (https://github.com/Arnav3241)",
        "detail": "Functions.Speak",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 5,
        "importPath": "Functions.Speak",
        "description": "Functions.Speak",
        "peekOfCode": "process = None\ndef Speak(*args):\n  global process\n  audio = \"\"\n  for i in args:\n    audio += str(i)\n  audio = audio.replace('\"', \"\")\n  audio = audio.replace('*', \"dash \")\n  with open(\"Database//Speak//Speak.txt\", \"w\") as file:\n    file.write(audio)",
        "detail": "Functions.Speak",
        "documentation": {}
    },
    {
        "label": "SpeakSync",
        "kind": 2,
        "importPath": "Functions.SpeakSync",
        "description": "Functions.SpeakSync",
        "peekOfCode": "def SpeakSync(*args):\n  print(\"Speaking\")\n  global process\n  audio = \"\"\n  for i in args:\n    audio += str(i)\n  audio = audio.replace('\"', \"\")\n  audio = audio.replace('*', \"dash \")\n  with open(\"Database//Speak//Speak.txt\", \"w\") as file:\n    file.write(audio)",
        "detail": "Functions.SpeakSync",
        "documentation": {}
    },
    {
        "label": "TTSK",
        "kind": 2,
        "importPath": "Functions.SpeakSync",
        "description": "Functions.SpeakSync",
        "peekOfCode": "def TTSK():\n  process.kill()\n  print(\"Speech Process Terminated\")\nif __name__ == \"__main__\":\n  while True:\n    SpeakSync(input(\">>> \"))\n# ? Author - Arnav Singh (https://github.com/Arnav3241)",
        "detail": "Functions.SpeakSync",
        "documentation": {}
    },
    {
        "label": "lightOn",
        "kind": 2,
        "importPath": "Hardware.hardware",
        "description": "Hardware.hardware",
        "peekOfCode": "def lightOn():\n  ser.write(b'o') \ndef LightOff():\n  ser.write(b'f') \nif __name__ == '__main__':\n  try:\n    while True: \n      try:\n        user_input = input(\"Enter 'on' to turn the relay ON, 'off' to turn the relay OFF, or 'q' to quit: \").strip().lower()\n        if user_input == 'q':",
        "detail": "Hardware.hardware",
        "documentation": {}
    },
    {
        "label": "LightOff",
        "kind": 2,
        "importPath": "Hardware.hardware",
        "description": "Hardware.hardware",
        "peekOfCode": "def LightOff():\n  ser.write(b'f') \nif __name__ == '__main__':\n  try:\n    while True: \n      try:\n        user_input = input(\"Enter 'on' to turn the relay ON, 'off' to turn the relay OFF, or 'q' to quit: \").strip().lower()\n        if user_input == 'q':\n          break\n        elif user_input == 'on':",
        "detail": "Hardware.hardware",
        "documentation": {}
    },
    {
        "label": "arduino_port",
        "kind": 5,
        "importPath": "Hardware.hardware",
        "description": "Hardware.hardware",
        "peekOfCode": "arduino_port = 'COM3'  \nbaud_rate = 9600  \nser = serial.Serial(arduino_port, baud_rate, timeout=1)\ntime.sleep(2)\ndef lightOn():\n  ser.write(b'o') \ndef LightOff():\n  ser.write(b'f') \nif __name__ == '__main__':\n  try:",
        "detail": "Hardware.hardware",
        "documentation": {}
    },
    {
        "label": "baud_rate",
        "kind": 5,
        "importPath": "Hardware.hardware",
        "description": "Hardware.hardware",
        "peekOfCode": "baud_rate = 9600  \nser = serial.Serial(arduino_port, baud_rate, timeout=1)\ntime.sleep(2)\ndef lightOn():\n  ser.write(b'o') \ndef LightOff():\n  ser.write(b'f') \nif __name__ == '__main__':\n  try:\n    while True: ",
        "detail": "Hardware.hardware",
        "documentation": {}
    },
    {
        "label": "ser",
        "kind": 5,
        "importPath": "Hardware.hardware",
        "description": "Hardware.hardware",
        "peekOfCode": "ser = serial.Serial(arduino_port, baud_rate, timeout=1)\ntime.sleep(2)\ndef lightOn():\n  ser.write(b'o') \ndef LightOff():\n  ser.write(b'f') \nif __name__ == '__main__':\n  try:\n    while True: \n      try:",
        "detail": "Hardware.hardware",
        "documentation": {}
    },
    {
        "label": "initialize_firebase",
        "kind": 2,
        "importPath": "Mobile.firebase_realtime",
        "description": "Mobile.firebase_realtime",
        "peekOfCode": "def initialize_firebase(cred_json_filepath, db_url, storage_bucket):\n    cred = credentials.Certificate(cred_json_filepath)\n    firebase_admin.initialize_app(cred, {\n        'storageBucket': storage_bucket,\n        'databaseURL': db_url\n    })\n# Download image from URL and save it locally\ndef download_image(image_url, filename=\"downloaded_image.jpg\"):\n    print(\"Trying to download image...\")\n    try:",
        "detail": "Mobile.firebase_realtime",
        "documentation": {}
    },
    {
        "label": "download_image",
        "kind": 2,
        "importPath": "Mobile.firebase_realtime",
        "description": "Mobile.firebase_realtime",
        "peekOfCode": "def download_image(image_url, filename=\"downloaded_image.jpg\"):\n    print(\"Trying to download image...\")\n    try:\n        response = requests.get(image_url)\n        response.raise_for_status()\n        with open(filename, 'wb') as f:\n            f.write(response.content)\n        print(\"Image downloaded successfully!\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Failed to download the image. Error: {e}\")",
        "detail": "Mobile.firebase_realtime",
        "documentation": {}
    },
    {
        "label": "delete_image_from_firebase",
        "kind": 2,
        "importPath": "Mobile.firebase_realtime",
        "description": "Mobile.firebase_realtime",
        "peekOfCode": "def delete_image_from_firebase(file_path):\n    bucket = storage.bucket()\n    blob = bucket.blob(file_path)\n    try:\n        blob.delete()\n        print(f\"Deleted image from Firebase Storage at: {file_path}\")\n    except Exception as e:\n        print(f\"Failed to delete image from Firebase Storage at: {file_path}. Error: {e}\")\n# Delete all images under the 'images/' directory in Firebase Storage\ndef delete_all_images_from_directory(directory):",
        "detail": "Mobile.firebase_realtime",
        "documentation": {}
    },
    {
        "label": "delete_all_images_from_directory",
        "kind": 2,
        "importPath": "Mobile.firebase_realtime",
        "description": "Mobile.firebase_realtime",
        "peekOfCode": "def delete_all_images_from_directory(directory):\n    bucket = storage.bucket()\n    blobs = bucket.list_blobs(prefix=directory)\n    for blob in blobs:\n        try:\n            blob.delete()\n            print(f\"Deleted image from Firebase Storage at: {blob.name}\")\n        except Exception as e:\n            print(f\"Failed to delete image from Firebase Storage at: {blob.name}. Error: {e}\")\n# Main function to link Firebase and handle image operations",
        "detail": "Mobile.firebase_realtime",
        "documentation": {}
    },
    {
        "label": "Image_Firebase_Link",
        "kind": 2,
        "importPath": "Mobile.firebase_realtime",
        "description": "Mobile.firebase_realtime",
        "peekOfCode": "def Image_Firebase_Link(db_url=DB_URL, cred_json_filepath=Cred_JSON_Filepath):\n    storage_bucket = storageBucket\n    initialize_firebase(cred_json_filepath, db_url, storage_bucket)\n    ref = db.reference('/Link')\n    print(\"Waiting for the image link to be uploaded...\")\n    while True:\n        current_value = ref.get()\n        if current_value:\n            print(f'Current value in the database: {current_value}')\n            ref.set('')  # Reset the database reference",
        "detail": "Mobile.firebase_realtime",
        "documentation": {}
    },
    {
        "label": "delete_all_images",
        "kind": 2,
        "importPath": "Mobile.firebase_realtime",
        "description": "Mobile.firebase_realtime",
        "peekOfCode": "def delete_all_images():\n    Image_Firebase_Link()  # Ensure Firebase is initialized\nif __name__ == '__main__':\n    delete_all_images()",
        "detail": "Mobile.firebase_realtime",
        "documentation": {}
    },
    {
        "label": "Speak1",
        "kind": 2,
        "importPath": "Tests.TTS.audioTest",
        "description": "Tests.TTS.audioTest",
        "peekOfCode": "def Speak1(text, voice=\"en-US-JennyNeural\"):\n  if text == \"\": return\n  command = f'edge-tts --voice \"{voice}\" --text \"{text}\" --write-media \"{os.getcwd()}\\\\Tests\\\\{voice}.mp3\"'\n  # command = f'edge-tts --voice \"{voice}\" --text \"{text}\" --write-media \"{os.getcwd()}\\\\Tests\\\\{voice}.mp3\"  --rate +25% --pitch +300Hz'\n  os.system(command)\n# Offline\ndef Speak2(text):  \n  Model.say(text)\n  print(f\"Jarvis : {text}\")\n  Model.runAndWait()",
        "detail": "Tests.TTS.audioTest",
        "documentation": {}
    },
    {
        "label": "Speak2",
        "kind": 2,
        "importPath": "Tests.TTS.audioTest",
        "description": "Tests.TTS.audioTest",
        "peekOfCode": "def Speak2(text):  \n  Model.say(text)\n  print(f\"Jarvis : {text}\")\n  Model.runAndWait()\ndef RunTTS(text):\n  # try: Speak1(text) \n  # except: Speak2(text)\n  Speak1(text)\nwith open('Database//Speak//Speak.txt', 'r') as file:\n  contents = file.read()",
        "detail": "Tests.TTS.audioTest",
        "documentation": {}
    },
    {
        "label": "RunTTS",
        "kind": 2,
        "importPath": "Tests.TTS.audioTest",
        "description": "Tests.TTS.audioTest",
        "peekOfCode": "def RunTTS(text):\n  # try: Speak1(text) \n  # except: Speak2(text)\n  Speak1(text)\nwith open('Database//Speak//Speak.txt', 'r') as file:\n  contents = file.read()\n  RunTTS(contents)\n#? Author - Arnav Singh (https://github.com/Arnav3241)",
        "detail": "Tests.TTS.audioTest",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 5,
        "importPath": "Tests.TTS.audioTest",
        "description": "Tests.TTS.audioTest",
        "peekOfCode": "Model = pyttsx3.init('sapi5')\nModel.setProperty('rate', 180)\n# Online\ndef Speak1(text, voice=\"en-US-JennyNeural\"):\n  if text == \"\": return\n  command = f'edge-tts --voice \"{voice}\" --text \"{text}\" --write-media \"{os.getcwd()}\\\\Tests\\\\{voice}.mp3\"'\n  # command = f'edge-tts --voice \"{voice}\" --text \"{text}\" --write-media \"{os.getcwd()}\\\\Tests\\\\{voice}.mp3\"  --rate +25% --pitch +300Hz'\n  os.system(command)\n# Offline\ndef Speak2(text):  ",
        "detail": "Tests.TTS.audioTest",
        "documentation": {}
    },
    {
        "label": "generation_config",
        "kind": 5,
        "importPath": "Tests.2",
        "description": "Tests.2",
        "peekOfCode": "generation_config = {\n  \"temperature\": 1,\n  \"top_p\": 0.95,\n  \"top_k\": 64,\n  \"max_output_tokens\": 8192,\n  \"response_mime_type\": \"text/plain\",\n}\nmodel = genai.GenerativeModel(\n  model_name=\"gemini-1.5-pro\",\n  generation_config=generation_config,",
        "detail": "Tests.2",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Tests.2",
        "description": "Tests.2",
        "peekOfCode": "model = genai.GenerativeModel(\n  model_name=\"gemini-1.5-pro\",\n  generation_config=generation_config,\n  # safety_settings = Adjust safety settings\n  # See https://ai.google.dev/gemini-api/docs/safety-settings\n)\nchat_session = model.start_chat(\n  history=[\n  ]\n)",
        "detail": "Tests.2",
        "documentation": {}
    },
    {
        "label": "chat_session",
        "kind": 5,
        "importPath": "Tests.2",
        "description": "Tests.2",
        "peekOfCode": "chat_session = model.start_chat(\n  history=[\n  ]\n)\nresponse = chat_session.send_message(\"Hi\")\nprint(response.text)",
        "detail": "Tests.2",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "Tests.2",
        "description": "Tests.2",
        "peekOfCode": "response = chat_session.send_message(\"Hi\")\nprint(response.text)",
        "detail": "Tests.2",
        "documentation": {}
    },
    {
        "label": "get_pdf_text",
        "kind": 2,
        "importPath": "Tests.a",
        "description": "Tests.a",
        "peekOfCode": "def get_pdf_text(pdf_docs):\n    text = \"\"\n    for pdf in pdf_docs:\n        pdf_reader = PdfReader(pdf)\n        for page in pdf_reader.pages:\n            text += page.extract_text()\n    return text\n# split text into chunks\ndef get_text_chunks(text):\n    splitter = RecursiveCharacterTextSplitter(chunk_size=10000, chunk_overlap=1000)",
        "detail": "Tests.a",
        "documentation": {}
    },
    {
        "label": "get_text_chunks",
        "kind": 2,
        "importPath": "Tests.a",
        "description": "Tests.a",
        "peekOfCode": "def get_text_chunks(text):\n    splitter = RecursiveCharacterTextSplitter(chunk_size=10000, chunk_overlap=1000)\n    chunks = splitter.split_text(text)\n    return chunks  # list of strings\n# get embeddings for each chunk\ndef get_vector_store(chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")  # type: ignore\n    vector_store = FAISS.from_texts(chunks, embedding=embeddings)\n    vector_store.save_local(\"faiss_index\")\ndef get_conversational_chain():",
        "detail": "Tests.a",
        "documentation": {}
    },
    {
        "label": "get_vector_store",
        "kind": 2,
        "importPath": "Tests.a",
        "description": "Tests.a",
        "peekOfCode": "def get_vector_store(chunks):\n    embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")  # type: ignore\n    vector_store = FAISS.from_texts(chunks, embedding=embeddings)\n    vector_store.save_local(\"faiss_index\")\ndef get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question as detailed as possible from the provided context, make sure to provide all the details, if the answer is not in\n    provided context just say, \"answer is not available in the context\", don't provide the wrong answer\\n\\n\n    Context:\\n {context}?\\n\n    Question: \\n{question}\\n",
        "detail": "Tests.a",
        "documentation": {}
    },
    {
        "label": "get_conversational_chain",
        "kind": 2,
        "importPath": "Tests.a",
        "description": "Tests.a",
        "peekOfCode": "def get_conversational_chain():\n    prompt_template = \"\"\"\n    Answer the question as detailed as possible from the provided context, make sure to provide all the details, if the answer is not in\n    provided context just say, \"answer is not available in the context\", don't provide the wrong answer\\n\\n\n    Context:\\n {context}?\\n\n    Question: \\n{question}\\n\n    Answer:\n    \"\"\"\n    model = ChatGoogleGenerativeAI(model=\"gemini-pro\", client=genai, temperature=0.3)\n    prompt = PromptTemplate(template=prompt_template, input_variables=[\"context\", \"question\"])",
        "detail": "Tests.a",
        "documentation": {}
    },
    {
        "label": "clear_chat_history",
        "kind": 2,
        "importPath": "Tests.a",
        "description": "Tests.a",
        "peekOfCode": "def clear_chat_history():\n    eel.clear_messages()\n@eel.expose\ndef process_pdfs(file_paths):\n    raw_text = get_pdf_text(file_paths)\n    text_chunks = get_text_chunks(raw_text)\n    get_vector_store(text_chunks)\n    return \"Done\"\n@eel.expose\ndef user_input(user_question):",
        "detail": "Tests.a",
        "documentation": {}
    },
    {
        "label": "process_pdfs",
        "kind": 2,
        "importPath": "Tests.a",
        "description": "Tests.a",
        "peekOfCode": "def process_pdfs(file_paths):\n    raw_text = get_pdf_text(file_paths)\n    text_chunks = get_text_chunks(raw_text)\n    get_vector_store(text_chunks)\n    return \"Done\"\n@eel.expose\ndef user_input(user_question):\n    embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")  # type: ignore\n    new_db = FAISS.load_local(\"faiss_index\", embeddings, allow_dangerous_deserialization=True)\n    docs = new_db.similarity_search(user_question)",
        "detail": "Tests.a",
        "documentation": {}
    },
    {
        "label": "user_input",
        "kind": 2,
        "importPath": "Tests.a",
        "description": "Tests.a",
        "peekOfCode": "def user_input(user_question):\n    embeddings = GoogleGenerativeAIEmbeddings(model=\"models/embedding-001\")  # type: ignore\n    new_db = FAISS.load_local(\"faiss_index\", embeddings, allow_dangerous_deserialization=True)\n    docs = new_db.similarity_search(user_question)\n    chain = get_conversational_chain()\n    response = chain({\"input_documents\": docs, \"question\": user_question}, return_only_outputs=True)\n    return response\neel.init('Tests//web')\neel.start('index.html', size=(1000, 600))",
        "detail": "Tests.a",
        "documentation": {}
    },
    {
        "label": "download_image",
        "kind": 2,
        "importPath": "Tests.firebase_realtime copy",
        "description": "Tests.firebase_realtime copy",
        "peekOfCode": "def download_image(image_url, filename=\"downloaded_image.jpg\"):\n    print(\"Trying to download image...\")\n    response = requests.get(image_url)\n    if response.status_code == 200:\n        with open(filename, 'wb') as f:\n            f.write(response.content)\n        print(\"Image downloaded successfully!\")\n    else:\n        print(\n            f\"Failed to download the image. Status code: {response.status_code}\")",
        "detail": "Tests.firebase_realtime copy",
        "documentation": {}
    },
    {
        "label": "Image_Firebase_Link",
        "kind": 2,
        "importPath": "Tests.firebase_realtime copy",
        "description": "Tests.firebase_realtime copy",
        "peekOfCode": "def Image_Firebase_Link(db_url='https://jarvis-5b1c9-default-rtdb.asia-southeast1.firebasedatabase.app/', cred_json_filepath=r'Mobile/jarvis-5b1c9-firebase-adminsdk-w4ny1-5cf73bb898.json'):\n    cred = credentials.Certificate(cred_json_filepath)\n    firebase_admin.initialize_app(cred, {\n        'databaseURL': db_url\n    })\n    ref = db.reference('/Link')\n    print(\"Waiting for the image link to be uploaded...\")\n    while True:\n        current_value = ref.get()\n        if current_value != '':",
        "detail": "Tests.firebase_realtime copy",
        "documentation": {}
    },
    {
        "label": "AddToUserHistory",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def AddToUserHistory(data, date, soul, role):\n  with open(\"Interface/History/History.json\", \"r\") as f:\n    history = json.load(f)\n  with open(\"Interface/History/History.json\", \"w\") as f:\n    history[str(soul)][\"history\"].append({\n      \"Data\": data,\n      \"Date\": date,\n      \"Role\": role\n    })\n    json.dump(history, f, indent=2)    ",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "RestoreHistory",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def RestoreHistory(soul):\n  print(\"Restoring history for \", soul)\n  with open(\"Interface/History/History.json\", \"r\") as f:\n    history = json.load(f)\n    print(history)\n    return history[str(soul)][\"history\"]\n#? Global Vars\nMainExeStarted = False\nChatDissabled = False\nSpeaking = False",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "ChangeGlobalVars",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul, Exit\n  if Var == \"MainExeStarted\": MainExeStarted = Value\n  if Var == \"ChatDissabled\": ChatDissabled = Value\n  if Var == \"Speaking\": Speaking = Value\n  if Var == \"GenResponse\": GenResponse = Value\n  if Var == \"SelectedSoul\": SelectedSoul = Value\n  if Var == \"Exit\": Exit = Value\n@eel.expose\ndef RefreshGlobalVars():",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "RefreshGlobalVars",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def RefreshGlobalVars():\n  return [\n    {\"Var\": \"MainExeStarted\", \"Value\": MainExeStarted},\n    {\"Var\": \"ChatDissabled\", \"Value\": ChatDissabled},\n    {\"Var\": \"Speaking\", \"Value\": Speaking},\n    {\"Var\": \"GenResponse\", \"Value\": GenResponse},\n    {\"Var\": \"SelectedSoul\", \"Value\": SelectedSoul},\n    {\"Var\": \"Exit\", \"Value\": Exit}\n  ]\n@eel.expose",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "PPPrint",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def PPPrint(data):\n  print(data)\n@eel.expose\ndef Terminate():\n  global Exit\n  Exit = True\ndef close(page, sockets_still_open):\n  global Exit\n  Exit = True\n  os._exit(0)",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "Terminate",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def Terminate():\n  global Exit\n  Exit = True\ndef close(page, sockets_still_open):\n  global Exit\n  Exit = True\n  os._exit(0)\n# @eel.expose\n# def MainExecution():\n#   while Exit == False:",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "close",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def close(page, sockets_still_open):\n  global Exit\n  Exit = True\n  os._exit(0)\n# @eel.expose\n# def MainExecution():\n#   while Exit == False:\n#     print(f\"Value of Exit: {Exit}\")\n#     time.sleep(1)\ndef funcVoiceExeProcess(): ",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "funcVoiceExeProcess",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def funcVoiceExeProcess(): \n  if __name__ == \"__main__\":\n    while True:\n      SpeakSync(\"VoiceExeProcess running...\")\n      # time.sleep(1)\ndef funcGUIprocess(): \n  global Exit\n  try:\n    eel.start(\"index.html\", size=(1500, 1200), position=(0, 0), close_callback=close)\n    VoiceExeProcess = multiprocessing.Process(target=funcVoiceExeProcess)",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "funcGUIprocess",
        "kind": 2,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "def funcGUIprocess(): \n  global Exit\n  try:\n    eel.start(\"index.html\", size=(1500, 1200), position=(0, 0), close_callback=close)\n    VoiceExeProcess = multiprocessing.Process(target=funcVoiceExeProcess)\n    VoiceExeProcess.start()\n    if Exit == True:\n      print(\"VoiceExeProcess terminated.\")\n      VoiceExeProcess.terminate()\n      VoiceExeProcess.join()",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "MainExeStarted",
        "kind": 5,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "MainExeStarted = False\nChatDissabled = False\nSpeaking = False\nGenResponse = False\nSelectedSoul = \"\"\nExit = False\n@eel.expose\ndef ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul, Exit\n  if Var == \"MainExeStarted\": MainExeStarted = Value",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "ChatDissabled",
        "kind": 5,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "ChatDissabled = False\nSpeaking = False\nGenResponse = False\nSelectedSoul = \"\"\nExit = False\n@eel.expose\ndef ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul, Exit\n  if Var == \"MainExeStarted\": MainExeStarted = Value\n  if Var == \"ChatDissabled\": ChatDissabled = Value",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "Speaking",
        "kind": 5,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "Speaking = False\nGenResponse = False\nSelectedSoul = \"\"\nExit = False\n@eel.expose\ndef ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul, Exit\n  if Var == \"MainExeStarted\": MainExeStarted = Value\n  if Var == \"ChatDissabled\": ChatDissabled = Value\n  if Var == \"Speaking\": Speaking = Value",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "GenResponse",
        "kind": 5,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "GenResponse = False\nSelectedSoul = \"\"\nExit = False\n@eel.expose\ndef ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul, Exit\n  if Var == \"MainExeStarted\": MainExeStarted = Value\n  if Var == \"ChatDissabled\": ChatDissabled = Value\n  if Var == \"Speaking\": Speaking = Value\n  if Var == \"GenResponse\": GenResponse = Value",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "SelectedSoul",
        "kind": 5,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "SelectedSoul = \"\"\nExit = False\n@eel.expose\ndef ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul, Exit\n  if Var == \"MainExeStarted\": MainExeStarted = Value\n  if Var == \"ChatDissabled\": ChatDissabled = Value\n  if Var == \"Speaking\": Speaking = Value\n  if Var == \"GenResponse\": GenResponse = Value\n  if Var == \"SelectedSoul\": SelectedSoul = Value",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "Exit",
        "kind": 5,
        "importPath": "Tests.main copy",
        "description": "Tests.main copy",
        "peekOfCode": "Exit = False\n@eel.expose\ndef ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul, Exit\n  if Var == \"MainExeStarted\": MainExeStarted = Value\n  if Var == \"ChatDissabled\": ChatDissabled = Value\n  if Var == \"Speaking\": Speaking = Value\n  if Var == \"GenResponse\": GenResponse = Value\n  if Var == \"SelectedSoul\": SelectedSoul = Value\n  if Var == \"Exit\": Exit = Value",
        "detail": "Tests.main copy",
        "documentation": {}
    },
    {
        "label": "Filter",
        "kind": 2,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "def Filter(txt):\n  pattern = r\"```python(.*?)```\"\n  matches = re.findall(pattern, txt, re.DOTALL)\n  if matches:\n   python_code = matches[0].strip()\n   return python_code\n  else:\n    return None\nprompt_general_instuctions = f\"\"\"\nYou are Jarvis, an AI model that has been created for the convenience of the user by Arnav Singh (https://github.com/Arnav3241) and Avi Sinha (https://github.com/Avi0981). ",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "addHistory",
        "kind": 2,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "def addHistory(index, input_, output_):\n  if __name__ == \"__main__\": time.sleep(1) \n  with open('Database//History//history.json', 'r') as f:\n    json_obj = json.loads(f.read())\n  #print(type(json_obj[str(index)][\"history\"]))\n  while len(json_obj[str(index)][\"history\"]) >= MAX_HIST:\n    json_obj[str(index)][\"history\"].pop(0)\n  json_obj[str(index)][\"history\"].append({\"input\": str(input_), \"output\": str(output_)})\n  with open('Database//History//history.json', 'w') as f:\n    json_str = json.dumps(json_obj)",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "updateName",
        "kind": 2,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "def updateName(index, name):\n  with open('Database//History//history.json', 'r') as f:\n    json_obj = json.loads(f.read())\n  json_obj[str(index)][\"name\"] = str(name)\n  json_str = json.dumps(json_obj)\n  with open('Database//History//history.json', 'w') as f:\n    f.write(json_str)\ndef Response(input):  \n  input = input.lower()\n  # global Cache",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 2,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "def Response(input):  \n  input = input.lower()\n  # global Cache\n  # if os.path.exists(file):\n  #   with open(file, 'r') as fData: \n  #     Cache = json.load(fData)\n  #     if Cache == \"\": Cache = {}\n  # else: Cache = []\n  # for element in Cache:\n  #   if element[\"input\"] == input:",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "Cache",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "Cache = []\nfile = r\"Cache/Cache.json\"\n#filter python code for gpt responce\ndef Filter(txt):\n  pattern = r\"```python(.*?)```\"\n  matches = re.findall(pattern, txt, re.DOTALL)\n  if matches:\n   python_code = matches[0].strip()\n   return python_code\n  else:",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "file",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "file = r\"Cache/Cache.json\"\n#filter python code for gpt responce\ndef Filter(txt):\n  pattern = r\"```python(.*?)```\"\n  matches = re.findall(pattern, txt, re.DOTALL)\n  if matches:\n   python_code = matches[0].strip()\n   return python_code\n  else:\n    return None",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "prompt_general_instuctions",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "prompt_general_instuctions = f\"\"\"\nYou are Jarvis, an AI model that has been created for the convenience of the user by Arnav Singh (https://github.com/Arnav3241) and Avi Sinha (https://github.com/Avi0981). \nYour job is to act as the brain of AI and perform various tasks which will be instructed how to do so later below.\nYou can respond only in the form of code. No text is allowed.\nOnly Python Language is allowed. Only a single piece of code is allowed which can be ran by pasting it in a python file.\nNOTE: If you want to say something to te user, you can not use the print() function. Instead you need to use the use the Speak function. It can be used directly by entering text into it. It;s syntax is given below:\nSpeak(\"Hello, I am Jarvis. How can I help you?\")\nNOTE: If there are multiple taskes given at once by the user and one of the tasks requires a query from the user, then ask it at the end after complting the other queries. If you have queries regarding multple commands just say it at the end in brief that wat all info do you need for the next time.\nNOTE: For Educational Conversations, explain concepts clearly and thoroughly. Use simple language and offer additional help if needed. Make sure to give examples.\nNOTE: In case of creative conversations, be imaginative and engaging. Use descriptive language and encourage user participation.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "prompt_capabilities",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "prompt_capabilities = f\"\"\"\nThese are the functions you can use in the code:\n1. Google Search: You can use the predefined function \"googleSearch()\" to search for anything on Google. The function takes a string as input and returns the search results.\nTakes a string as input and returns the search results.\nFormat:\n```python\na = googleSearch(\"What is the capital of India?\")\nSpeak(a + \"Do you want to know more about it?\")\n```\n2. Weather: You can use the predefined function \"getWeather()\" to get the current weather of any location. The function takes a string as input and returns the weather information.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = googleSearch(\"What is the capital of India?\")\nSpeak(a + \"Do you want to know more about it?\")\n```\n2. Weather: You can use the predefined function \"getWeather()\" to get the current weather of any location. The function takes a string as input and returns the weather information.\nTakes a string for location as input and returns the weather information in form of a complete sentence.\nFormat:\n```python\na = getWeather(\"Mumbai\")\nSpeak(a)\n```",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getWeather(\"Mumbai\")\nSpeak(a)\n```\n3. Send WhatsApp Message: You can use the predefined function \"sendWhatsApp()\" to send a WhatsApp message to any contact mentioned above. The function takes two strings as input, the contact name and the message to be sent. If the whatsapp term or even the \"message\" term is used, Consider it to be a whatsapp message.\nFormat:\n```python\nmessage = \"I am going to be late today\"\nsendWhatsApp(\"Mom\", message)\nSpeak(\"Message sent to Mom\" + message)\n```",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "message",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "message = \"I am going to be late today\"\nsendWhatsApp(\"Mom\", message)\nSpeak(\"Message sent to Mom\" + message)\n```\n4. Play Music: You can use the predefined function \"playMusic()\" to play music from YouTube. The function takes a string as input, the name of the song, and plays it on YouTube.\nFormat:\n```python\nSpeak(\"Playing Shape of You on Youtube, Sir.\")\nplayMusic(\"Shape of You\")\n```",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getNews()\nSpeak(a)\n```\n6. To Do List Automation: You can use the predefined function \"GetToDoList()\" to get the elements of the To Do List and Speak them. The function takes no input and returns the To Do List.\nFormat:\n```python\nSpeak(\"Here is your To Do List for today which you have asked me to add by now.\")\na = GetToDoList()\nSpeak(a)\n```",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = GetToDoList()\nSpeak(a)\n```\n7. Add To Do List: You can use the predefined function \"AddToDoList()\" to add an element to the To Do List. The function takes a string as input, the element to be added, and returns the updated To Do List.\nFormat:\n```python\na = AddToDoList(\"Buy Groceries\")\nSpeak(\"Added Buy Groceries to your To Do List\")\n```\n8. Remove from To Do List: You can use the predefined function \"RemoveToDoList()\" to remove an element from the To Do List. The function takes a string as input, the element to be removed, and returns the updated To Do List.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = AddToDoList(\"Buy Groceries\")\nSpeak(\"Added Buy Groceries to your To Do List\")\n```\n8. Remove from To Do List: You can use the predefined function \"RemoveToDoList()\" to remove an element from the To Do List. The function takes a string as input, the element to be removed, and returns the updated To Do List.\nFormat:\n```python\na = RemoveToDoList(\"Buy Groceries\")\nSpeak(\"Removed Buy Groceries from your To Do List\")\n```\n9. Set Reminder: You can use the predefined function \"SetReminder()\" to set a reminder. The function takes two strings as input, the reminder message and the time, and returns the reminder message.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = RemoveToDoList(\"Buy Groceries\")\nSpeak(\"Removed Buy Groceries from your To Do List\")\n```\n9. Set Reminder: You can use the predefined function \"SetReminder()\" to set a reminder. The function takes two strings as input, the reminder message and the time, and returns the reminder message.\nFormat:\n```python\na = SetReminder(\"Meeting with the client\", \"4:00 PM\")\nSpeak(\"Reminder set for Meeting with the client at 4:00 PM\")\n```\n9. Getting System Information: You can use the predefined function \"getSystemInfo()\" to get the System Information. The function takes one input and returns the Desired System Information.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = SetReminder(\"Meeting with the client\", \"4:00 PM\")\nSpeak(\"Reminder set for Meeting with the client at 4:00 PM\")\n```\n9. Getting System Information: You can use the predefined function \"getSystemInfo()\" to get the System Information. The function takes one input and returns the Desired System Information.\nHere are a fixed no of things that you can ask for (at once only): CPU usage, RAM usage, Disk usage and Battery percentage only.\n```python\nSpeak(\"Here is the System Information you asked for my master.\")\nCpu = getSystemInfo(\"CPU\")\nRam = getSystemInfo(\"RAM\")\nDisk = getSystemInfo(\"DISK\")",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "Cpu",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "Cpu = getSystemInfo(\"CPU\")\nRam = getSystemInfo(\"RAM\")\nDisk = getSystemInfo(\"DISK\")\nBattery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "Ram",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "Ram = getSystemInfo(\"RAM\")\nDisk = getSystemInfo(\"DISK\")\nBattery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.\nFormat:",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "Disk",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "Disk = getSystemInfo(\"DISK\")\nBattery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.\nFormat:\n```python",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "Battery",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "Battery = getSystemInfo(\"BATTERY\")\nSpeak(\"CPU Usage is \" + Cpu)\nSpeak(\"RAM Usage is \" + Ram)\nSpeak(\"Disk Usage is \" + Disk)\nSpeak(\"Battery Percentage is \" + Battery)\n```\n10. Generating a Random Number: You can use the predefined function \"generateRandomNumber()\" to generate a random number. The function takes two integers as input, the lower and upper limits, and returns a random number between them.\nFormat:\n```python\na = generateRandomNumber(1, 100)",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = generateRandomNumber(1, 100)\nSpeak(\"The random number is \" + a)\n```\n11. Getting the Current Time: You can use the predefined function \"getCurrentTime()\" to get the current time. The function takes no input and returns the current time.\nFormat:\n```python\na = getCurrentTime()\nSpeak(\"The current time is \" + a)\n```\n12. Getting the Current Day: You can use the predefined function \"getCurrentDay()\" to get the current day. The function takes no input and returns the current day.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getCurrentTime()\nSpeak(\"The current time is \" + a)\n```\n12. Getting the Current Day: You can use the predefined function \"getCurrentDay()\" to get the current day. The function takes no input and returns the current day.\nFormat:\n```python\na = getCurrentDay()\nSpeak(\"Today is \" + a)\n```\n13. Getting Selected Data: You can use the predefined function \"getSelectedData()\" to get the selected data. The function takes in no input and returns the selected data.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getCurrentDay()\nSpeak(\"Today is \" + a)\n```\n13. Getting Selected Data: You can use the predefined function \"getSelectedData()\" to get the selected data. The function takes in no input and returns the selected data.\nFormat:\n```python\na = getSelectedData()\n```\n(Eg: If the user has selected a text on the screen and wants you to read it)\n```python",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getSelectedData()\n```\n(Eg: If the user has selected a text on the screen and wants you to read it)\n```python\na = getSelectedData()\nSpeak(\"The thing you asked me to read is \" + a)\n```\n(Eg: If the user has selected a term and wants you to open a wikipedia page for it.)\n```python\na = getSelectedData()",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getSelectedData()\nSpeak(\"The thing you asked me to read is \" + a)\n```\n(Eg: If the user has selected a term and wants you to open a wikipedia page for it.)\n```python\na = getSelectedData()\nSpeak(\"Opening the Wikipedia page for \" + a)\nwebbrowser.open(\"https://en.wikipedia.org/w/index.php?fulltext=1&profile=default&search=\" + a)\n```\n14. Getting Stock prices: You can use the predefined function \"getStockPrices()\" to get the stock prices of a company. The function takes a string as input, the name of the company, and returns the stock prices.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getSelectedData()\nSpeak(\"Opening the Wikipedia page for \" + a)\nwebbrowser.open(\"https://en.wikipedia.org/w/index.php?fulltext=1&profile=default&search=\" + a)\n```\n14. Getting Stock prices: You can use the predefined function \"getStockPrices()\" to get the stock prices of a company. The function takes a string as input, the name of the company, and returns the stock prices.\nFormat:\n```python\na = getStockPrices(\"Apple\")\nSpeak(\"The stock prices of Apple are \" + a)\n```",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getStockPrices(\"Apple\")\nSpeak(\"The stock prices of Apple are \" + a)\n```\n15. Text Summarisation: You can use the predefined function \"textSummarisation()\" to summarise a text. The function takes a string as input, the text to be summarised, and returns the summary.\nFormat:\n```python\na = textSummarisation(\" ... ... ... \")\nSpeak(\"The summary of the text is \" + a)\n```\n(eg: If the user has selected a text on the screen and wants you to summarise it)",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = textSummarisation(\" ... ... ... \")\nSpeak(\"The summary of the text is \" + a)\n```\n(eg: If the user has selected a text on the screen and wants you to summarise it)\n```python\na = getSelectedData()\nb = textSummarisation(a)\nSpeak(\"The summary of the text you asked me to summarise is \" + b)\n```\n16. Text Translation: You can use the predefined function \"textTranslation()\" to translate a text. The function takes no input and open up a different app for Text translation.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getSelectedData()\nb = textSummarisation(a)\nSpeak(\"The summary of the text you asked me to summarise is \" + b)\n```\n16. Text Translation: You can use the predefined function \"textTranslation()\" to translate a text. The function takes no input and open up a different app for Text translation.\nFormat:\n```python\nSpeak(\"Opening the Text Translation window for you.\")\ntextTranslation()\n```",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "b = textSummarisation(a)\nSpeak(\"The summary of the text you asked me to summarise is \" + b)\n```\n16. Text Translation: You can use the predefined function \"textTranslation()\" to translate a text. The function takes no input and open up a different app for Text translation.\nFormat:\n```python\nSpeak(\"Opening the Text Translation window for you.\")\ntextTranslation()\n```\n17. Copy to Clipboard: You can use the predefined function \"copyToClipboard()\" to copy a text to the clipboard. The function takes a string as input, the text to be copied, and returns nothing.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getSelectedData()\nb = textSummarisation(a)\ncopyToClipboard(b)\nSpeak(\"The summary of the text you asked me to summarise has been copied to the clipboard.\")\n```\n18. Data Visualisation: You can use the predefined function \"dataVisualisation()\" to visualise data. The function takes a sting data to get the data to be visualised in form of a para and opens up a different app for Data Visualisation.\nFormat:\n```python\ndataVisualisation(\" ... ... ... \")\n```",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "b = textSummarisation(a)\ncopyToClipboard(b)\nSpeak(\"The summary of the text you asked me to summarise has been copied to the clipboard.\")\n```\n18. Data Visualisation: You can use the predefined function \"dataVisualisation()\" to visualise data. The function takes a sting data to get the data to be visualised in form of a para and opens up a different app for Data Visualisation.\nFormat:\n```python\ndataVisualisation(\" ... ... ... \")\n```\n(eg: If the user has selected a text on the screen and wants you to visualise it)",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = getSelectedData()\ndataVisualisation(a)\nSpeak(\"The data you asked me to visualise has been opened in a new window.\")\n```\n19. Power Management: You can use the prefefined functions Sleep(), Shutdown(), Restart() and Lock() to perform the respective tasks. Takes no input and returns nothing.\nFormats respectively for each case:\n```python\nSleep()\n```\n```python",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = browserAutomation(\"Open a new tab\")\nSpeak(\"A new tab has been opened for you, my Master.\")\n```\n21. New meeting: You can use the predefined function \"newMeeting()\" to open a new meeting. The function takes no input and returns the no output.\nFormat:\n```python\nnewMeeting()\nSpeak(\"A new meeting has been opened for you, Sir.\")\n```\n22. Home Automation: For this, you have two functions \"turnOn()\" and \"turnOff()\". You can use the predefined function \"turnOn()\" to turn on the lights and \"turnOff()\" to turn off the lights. The function takes no input and returns the output.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = wordRelations(\"Apple\", \"meaning\")\nSpeak(\"The meaning of Apple is \" + a)\n```\n24. Math Problem: You can use the predefined function \"mathProblem()\" to solve a math problem. The function takes a string as input, the math problem, and returns a solution.\nFormat:\n```python\na = mathProblem(\"What is 326 multiplied by 4 divided by 2\")\nSpeak(\"The solution to this is \" + a)\n```\n25. WriteViaKeyboard: You can use the predefined function \"writeViaKeyboard()\" to write using the keyboard. The function takes a string as input, the text to be written, and returns no output.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = mathProblem(\"What is 326 multiplied by 4 divided by 2\")\nSpeak(\"The solution to this is \" + a)\n```\n25. WriteViaKeyboard: You can use the predefined function \"writeViaKeyboard()\" to write using the keyboard. The function takes a string as input, the text to be written, and returns no output.\nFormat:\n```python\nwriteViaKeyboard(\"Hello, I am Jarvis.\")\nSpeak(\"The text has been written.\")\n```\n26. Voice Typing: You can use the predefined function \"voiceTyping()\" to type using voice. The function takes no input and gives the output. You may want to even use the \"writeViaKeyboard()\" function to write the text.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "a = voiceTyping()\nwriteViaKeyboard(a)\nSpeak(\"The text has been written.\")\n```\n# TODO: <Functions Need to be defined>\n\"\"\"\nprompt_history = f\"\"\"\n\"\"\"\nprompt_summary = f\"\"\"\n# Dare not write any form of text except for code.",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "prompt_history",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "prompt_history = f\"\"\"\n\"\"\"\nprompt_summary = f\"\"\"\n# Dare not write any form of text except for code.\n# Dare not to define the speak function.\n# Dare not the derive known info from the web.\n# Make sure to sound like a cool dude.\n# Dare not use any input function. If you want to ask something from the user, use the speak function and just directly ask it.\n# The userbase is Indian. So, make sure to use Indian examples and references if used.\n# At no cost you may change the syntax of the output. It is:",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "prompt_summary",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "prompt_summary = f\"\"\"\n# Dare not write any form of text except for code.\n# Dare not to define the speak function.\n# Dare not the derive known info from the web.\n# Make sure to sound like a cool dude.\n# Dare not use any input function. If you want to ask something from the user, use the speak function and just directly ask it.\n# The userbase is Indian. So, make sure to use Indian examples and references if used.\n# At no cost you may change the syntax of the output. It is:\n```python\n-code-",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "MAX_HIST",
        "kind": 5,
        "importPath": "Tests.r1",
        "description": "Tests.r1",
        "peekOfCode": "MAX_HIST = 10\nwith open('api_keys.json', 'r') as f:\n  api = json.loads(f.read())[\"gemini1\"]\ndef addHistory(index, input_, output_):\n  if __name__ == \"__main__\": time.sleep(1) \n  with open('Database//History//history.json', 'r') as f:\n    json_obj = json.loads(f.read())\n  #print(type(json_obj[str(index)][\"history\"]))\n  while len(json_obj[str(index)][\"history\"]) >= MAX_HIST:\n    json_obj[str(index)][\"history\"].pop(0)",
        "detail": "Tests.r1",
        "documentation": {}
    },
    {
        "label": "TEXT",
        "kind": 5,
        "importPath": "Tests.speaktest2",
        "description": "Tests.speaktest2",
        "peekOfCode": "TEXT = \"Hello World!\"\nVOICE = \"en-GB-SoniaNeural\"\nOUTPUT_FILE = \"Assets\\\\Audio\\\\TdTS.mp3\"\nasync def amain(text) -> None:\n    \"\"\"Main function\"\"\"\n    communicate = edge_tts.Communicate(text, VOICE)\n    with open(OUTPUT_FILE, \"wb\") as file:\n        async for chunk in communicate.stream():\n            if chunk[\"type\"] == \"audio\":\n                file.write(chunk[\"data\"])",
        "detail": "Tests.speaktest2",
        "documentation": {}
    },
    {
        "label": "VOICE",
        "kind": 5,
        "importPath": "Tests.speaktest2",
        "description": "Tests.speaktest2",
        "peekOfCode": "VOICE = \"en-GB-SoniaNeural\"\nOUTPUT_FILE = \"Assets\\\\Audio\\\\TdTS.mp3\"\nasync def amain(text) -> None:\n    \"\"\"Main function\"\"\"\n    communicate = edge_tts.Communicate(text, VOICE)\n    with open(OUTPUT_FILE, \"wb\") as file:\n        async for chunk in communicate.stream():\n            if chunk[\"type\"] == \"audio\":\n                file.write(chunk[\"data\"])\n            elif chunk[\"type\"] == \"WordBoundary\":",
        "detail": "Tests.speaktest2",
        "documentation": {}
    },
    {
        "label": "OUTPUT_FILE",
        "kind": 5,
        "importPath": "Tests.speaktest2",
        "description": "Tests.speaktest2",
        "peekOfCode": "OUTPUT_FILE = \"Assets\\\\Audio\\\\TdTS.mp3\"\nasync def amain(text) -> None:\n    \"\"\"Main function\"\"\"\n    communicate = edge_tts.Communicate(text, VOICE)\n    with open(OUTPUT_FILE, \"wb\") as file:\n        async for chunk in communicate.stream():\n            if chunk[\"type\"] == \"audio\":\n                file.write(chunk[\"data\"])\n            elif chunk[\"type\"] == \"WordBoundary\":\n                print(f\"WordBoundary: {chunk}\")",
        "detail": "Tests.speaktest2",
        "documentation": {}
    },
    {
        "label": "#path_to_video_file",
        "kind": 5,
        "importPath": "Tests.test",
        "description": "Tests.test",
        "peekOfCode": "#path_to_video_file = 'Sherlock_Jr_FullMovie.mp4'\n# Upload the video using the Files API\n#video_file = genai.upload_file(path=path_to_video_file)\n# Wait for the file to finish processing\n'''\nwhile video_file.state.name == 'PROCESSING':\n  print('Waiting for video to be processed.')\n  time.sleep(2)\n  video_file = genai.get_file(video_file.name)\nprint(f'Video processing complete: {video_file.uri}')",
        "detail": "Tests.test",
        "documentation": {}
    },
    {
        "label": "#video_file",
        "kind": 5,
        "importPath": "Tests.test",
        "description": "Tests.test",
        "peekOfCode": "#video_file = genai.upload_file(path=path_to_video_file)\n# Wait for the file to finish processing\n'''\nwhile video_file.state.name == 'PROCESSING':\n  print('Waiting for video to be processed.')\n  time.sleep(2)\n  video_file = genai.get_file(video_file.name)\nprint(f'Video processing complete: {video_file.uri}')\n'''\n# Create a cache with a 5 minute TTL",
        "detail": "Tests.test",
        "documentation": {}
    },
    {
        "label": "cache",
        "kind": 5,
        "importPath": "Tests.test",
        "description": "Tests.test",
        "peekOfCode": "cache = cache.CachedContent.create(\n    model='models/gemini-1.5-flash-001',\n    display_name='sherlock jr movie', # used to identify the cache\n    system_instruction=(\n        'You are an expert video analyzer, and your job is to answer '\n        'the user\\'s query based on the video file you have access to.'\n    ),\n    contents=\"Hello\",\n    ttl=datetime.timedelta(minutes=5),\n)",
        "detail": "Tests.test",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Tests.test",
        "description": "Tests.test",
        "peekOfCode": "model = genai.GenerativeModel.from_cached_content(cached_content=cache)\n# Query the model\nresponse = model.generate_content([(\n    'Introduce different characters in the movie by describing '\n    'their personality, looks, and names. Also list the timestamps '\n    'they were introduced for the first time.')])\nprint(response.usage_metadata)\n# The output should look something like this:\n#\n# prompt_token_count: 696219",
        "detail": "Tests.test",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "Tests.test",
        "description": "Tests.test",
        "peekOfCode": "response = model.generate_content([(\n    'Introduce different characters in the movie by describing '\n    'their personality, looks, and names. Also list the timestamps '\n    'they were introduced for the first time.')])\nprint(response.usage_metadata)\n# The output should look something like this:\n#\n# prompt_token_count: 696219\n# cached_content_token_count: 696190\n# candidates_token_count: 214",
        "detail": "Tests.test",
        "documentation": {}
    },
    {
        "label": "Speak",
        "kind": 2,
        "importPath": "Tests.test1",
        "description": "Tests.test1",
        "peekOfCode": "def Speak(text):\n    engine.say(text)\n    engine.runAndWait()\nSpeak(\"Okay buddy, opening chrome, insta, twitter, amazon, pw.com, word, excel, trello, slides, and powerpoint for you. Anything else you need, just let me know!\")\nwebbrowser.open(\"https://www.google.com/chrome/\")\nwebbrowser.open(\"https://www.instagram.com/\")\nwebbrowser.open(\"https://twitter.com/\")\nwebbrowser.open(\"https://www.amazon.in/\")\nwebbrowser.open(\"https://pw.live/\")\nwebbrowser.open(\"https://www.microsoft.com/en-in/microsoft-365/word\")",
        "detail": "Tests.test1",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "Tests.test1",
        "description": "Tests.test1",
        "peekOfCode": "engine = pyttsx3.init()\n# Define the Speak function\ndef Speak(text):\n    engine.say(text)\n    engine.runAndWait()\nSpeak(\"Okay buddy, opening chrome, insta, twitter, amazon, pw.com, word, excel, trello, slides, and powerpoint for you. Anything else you need, just let me know!\")\nwebbrowser.open(\"https://www.google.com/chrome/\")\nwebbrowser.open(\"https://www.instagram.com/\")\nwebbrowser.open(\"https://twitter.com/\")\nwebbrowser.open(\"https://www.amazon.in/\")",
        "detail": "Tests.test1",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": "Tests.test_re",
        "description": "Tests.test_re",
        "peekOfCode": "code = \"\"\"\nSpeak(\"Hey dude, I'm doing fantastic, thanks for asking!. Always happy to help a friend out.\")\nSpeak(\"Opening Chrome for you, bro. Hope you are going to do something productive today.\")\nwebbrowser.open(\"https://www.google.com/\")\nSpeak(\"Opening File Explorer.  Let's see what you've got in store!.\")\nos.system(\"start explorer\")\nSpeak(\"Photosynthesis is like, plants using sunlight to make their own food, man. They're like, the ultimate chefs using light, water, and carbon dioxide to cook up some delicious glucose.\")\nSpeak(\"The atomic number of sulfur is 16, my friend. Remember that!.\")\nSpeak(\"Okay, opening Amazon and Flipkart for you. Hope you find the perfect keyboard under 3,000 rupees!. Let me know if you want me to sort it by anything\")\nwebbrowser.open(\"https://www.amazon.in/s?k=best+keyboard+under+3000+rupees\")",
        "detail": "Tests.test_re",
        "documentation": {}
    },
    {
        "label": "speak_statements",
        "kind": 5,
        "importPath": "Tests.test_re",
        "description": "Tests.test_re",
        "peekOfCode": "speak_statements = re.findall(r'Speak\\(\"(.*?)\"\\)', code)\n# Return the list of Speak statements\nprint(speak_statements)",
        "detail": "Tests.test_re",
        "documentation": {}
    },
    {
        "label": "ExecuteCode",
        "kind": 2,
        "importPath": "Utils.Execute",
        "description": "Utils.Execute",
        "peekOfCode": "def ExecuteCode(code_str: str) -> None:\n    try:\n        exec(code_str)\n    except Exception as e:\n        print('Error in ExecuteCode function(Execute.py), code contained in input string has wrong syntax OR wrong datatype argument. Error:', e)\n# Test cases\nif __name__ == '__main__':\n    ExecuteCode('a = input(\"Ji\")')\n    ExecuteCode('print(\"hi\")\\nprint(\"yo\")')\n    ExecuteCode('import math\\nprint(math.sqrt(49))')",
        "detail": "Utils.Execute",
        "documentation": {}
    },
    {
        "label": "Speak1",
        "kind": 2,
        "importPath": "Utils.RunTTS",
        "description": "Utils.RunTTS",
        "peekOfCode": "def Speak1(text, voice=\"en-US-SteffanNeural\"):\n  if text == \"\": return\n  command = f'edge-tts --voice \"{voice}\" --text \"{text}\" --write-media \"{os.getcwd()}\\\\Assets\\\\Audio\\\\TTS.mp3\"'\n  os.system(command)\n  playsound(\"Assets/Audio/TTS.mp3\")\n# Offline\ndef Speak2(text):  \n  Model.say(text)\n  print(f\"Jarvis : {text}\")\n  Model.runAndWait()",
        "detail": "Utils.RunTTS",
        "documentation": {}
    },
    {
        "label": "Speak2",
        "kind": 2,
        "importPath": "Utils.RunTTS",
        "description": "Utils.RunTTS",
        "peekOfCode": "def Speak2(text):  \n  Model.say(text)\n  print(f\"Jarvis : {text}\")\n  Model.runAndWait()\ndef RunTTS(text, voice=\"en-US-SteffanNeural\"):\n  # try: Speak1(text) \n  # except: Speak2(text)\n  if voice == \"en-default-DavidNeural\": Speak2(text, \"en-US-DavidNeural\")\n  else: Speak1(text, voice)\nwith open('Database//Speak//Speak.txt', 'r') as file:",
        "detail": "Utils.RunTTS",
        "documentation": {}
    },
    {
        "label": "RunTTS",
        "kind": 2,
        "importPath": "Utils.RunTTS",
        "description": "Utils.RunTTS",
        "peekOfCode": "def RunTTS(text, voice=\"en-US-SteffanNeural\"):\n  # try: Speak1(text) \n  # except: Speak2(text)\n  if voice == \"en-default-DavidNeural\": Speak2(text, \"en-US-DavidNeural\")\n  else: Speak1(text, voice)\nwith open('Database//Speak//Speak.txt', 'r') as file:\n  contents = file.read()\n  RunTTS(contents)\n#? Author - Arnav Singh (https://github.com/Arnav3241)",
        "detail": "Utils.RunTTS",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 5,
        "importPath": "Utils.RunTTS",
        "description": "Utils.RunTTS",
        "peekOfCode": "Model = pyttsx3.init('sapi5')\nModel.setProperty('rate', 180)\n# Online\ndef Speak1(text, voice=\"en-US-SteffanNeural\"):\n  if text == \"\": return\n  command = f'edge-tts --voice \"{voice}\" --text \"{text}\" --write-media \"{os.getcwd()}\\\\Assets\\\\Audio\\\\TTS.mp3\"'\n  os.system(command)\n  playsound(\"Assets/Audio/TTS.mp3\")\n# Offline\ndef Speak2(text):  ",
        "detail": "Utils.RunTTS",
        "documentation": {}
    },
    {
        "label": "DictProperty",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class DictProperty(object):\n    ''' Property that maps to a key in a local dict-like attribute. '''\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter, self.key = func, self.key or func.__name__\n        return self\n    def __get__(self, obj, cls):\n        if obj is None: return self",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "cached_property",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class cached_property(object):\n    ''' A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. '''\n    def __init__(self, func):\n        self.__doc__ = getattr(func, '__doc__')\n        self.func = func\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "lazy_attribute",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class lazy_attribute(object):\n    ''' A property that caches itself to the class object. '''\n    def __init__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter = func\n    def __get__(self, obj, cls):\n        value = self.getter(cls)\n        setattr(cls, self.__name__, value)\n        return value\n###############################################################################",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "BottleException",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class BottleException(Exception):\n    \"\"\" A base class for exceptions used by bottle. \"\"\"\n    pass\n###############################################################################\n# Routing ######################################################################\n###############################################################################\nclass RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\nclass RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "RouteError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\nclass RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all\n        plugins are re-applied. \"\"\"\nclass RouterUnknownModeError(RouteError): pass\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "RouteReset",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all\n        plugins are re-applied. \"\"\"\nclass RouterUnknownModeError(RouteError): pass\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\ndef _re_flatten(p):\n    ''' Turn all capturing groups in a regular expression pattern into",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "RouterUnknownModeError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class RouterUnknownModeError(RouteError): pass\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\ndef _re_flatten(p):\n    ''' Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. '''\n    if '(' not in p: return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))',",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "RouteSyntaxError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\ndef _re_flatten(p):\n    ''' Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. '''\n    if '(' not in p: return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))',\n        lambda m: m.group(0) if len(m.group(1)) % 2 else m.group(1) + '(?:', p)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "RouteBuildError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\ndef _re_flatten(p):\n    ''' Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. '''\n    if '(' not in p: return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))',\n        lambda m: m.group(0) if len(m.group(1)) % 2 else m.group(1) + '(?:', p)\nclass Router(object):\n    ''' A Router is an ordered collection of route->target pairs. It is used to",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "Router",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class Router(object):\n    ''' A Router is an ordered collection of route->target pairs. It is used to\n        efficiently match WSGI requests against a number of routes and return\n        the first target that satisfies the request. The target may be anything,\n        usually a string, ID or callable object. A route consists of a path-rule\n        and a HTTP method.\n        The path-rule is either a static path (e.g. `/contact`) or a dynamic\n        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax\n        and details on the matching order are described in docs:`routing`.\n    '''",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "Route",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class Route(object):\n    ''' This class wraps a route callback along with route specific metadata and\n        configuration and applies Plugins on demand. It is also responsible for\n        turing an URL path rule into a regular expression usable by the Router.\n    '''\n    def __init__(self, app, rule, method, callback, name=None,\n                 plugins=None, skiplist=None, **config):\n        #: The application this route is installed to.\n        self.app = app\n        #: The path-rule string (e.g. ``/wiki/:page``).",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "Bottle",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class Bottle(object):\n    \"\"\" Each Bottle object represents a single, distinct web application and\n        consists of routes, callbacks, plugins, resources and configuration.\n        Instances are callable WSGI applications.\n        :param catchall: If true (default), handle all exceptions. Turn off to\n                         let debugging middleware handle exceptions.\n    \"\"\"\n    def __init__(self, catchall=True, autojson=True):\n        #: A :class:`ConfigDict` for app specific configuration.\n        self.config = ConfigDict()",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "BaseRequest",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class BaseRequest(object):\n    \"\"\" A wrapper for WSGI environment dictionaries that adds a lot of\n        convenient access methods and properties. Most of them are read-only.\n        Adding new attributes to a request actually adds them to the environ\n        dictionary (as 'bottle.request.ext.<name>'). This is the recommended\n        way to store and access request-specific data.\n    \"\"\"\n    __slots__ = ('environ')\n    #: Maximum size of memory buffer for :attr:`body` in bytes.\n    MEMFILE_MAX = 102400",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HeaderProperty",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class HeaderProperty(object):\n    def __init__(self, name, reader=None, writer=None, default=''):\n        self.name, self.default = name, default\n        self.reader, self.writer = reader, writer\n        self.__doc__ = 'Current value of the %r header.' % name.title()\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.get_header(self.name, self.default)\n        return self.reader(value) if self.reader else value\n    def __set__(self, obj, value):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "BaseResponse",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class BaseResponse(object):\n    \"\"\" Storage class for a response body as well as headers and cookies.\n        This class does support dict-like case-insensitive item-access to\n        headers, but is NOT a dict. Most notably, iterating over a response\n        yields parts of the body and not the headers.\n        :param body: The response body as one of the supported types.\n        :param status: Either an HTTP status code (e.g. 200) or a status line\n                       including the reason phrase (e.g. '200 OK').\n        :param headers: A dictionary or a list of name-value pairs.\n        Additional keyword arguments are added to the list of headers.",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "LocalRequest",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class LocalRequest(BaseRequest):\n    ''' A thread-local subclass of :class:`BaseRequest` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`request`). If accessed during a\n        request/response cycle, this instance always refers to the *current*\n        request (even on a multithreaded server). '''\n    bind = BaseRequest.__init__\n    environ = local_property()\nclass LocalResponse(BaseResponse):\n    ''' A thread-local subclass of :class:`BaseResponse` with a different",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "LocalResponse",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class LocalResponse(BaseResponse):\n    ''' A thread-local subclass of :class:`BaseResponse` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`response`). Its attributes are used\n        to build the HTTP response at the end of the request/response cycle.\n    '''\n    bind = BaseResponse.__init__\n    _status_line = local_property()\n    _status_code = local_property()\n    _cookies     = local_property()",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTPResponse",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n    def apply(self, response):\n        response._status_code = self._status_code\n        response._status_line = self._status_line\n        response._headers = self._headers\n        response._cookies = self._cookies\n        response.body = self.body\nclass HTTPError(HTTPResponse):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class HTTPError(HTTPResponse):\n    default_status = 500\n    def __init__(self, status=None, body=None, exception=None, traceback=None,\n                 **options):\n        self.exception = exception\n        self.traceback = traceback\n        super(HTTPError, self).__init__(body, status, **options)\n###############################################################################\n# Plugins ######################################################################\n###############################################################################",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "PluginError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class PluginError(BottleException): pass\nclass JSONPlugin(object):\n    name = 'json'\n    api  = 2\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not dumps: return callback\n        def wrapper(*a, **ka):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "JSONPlugin",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class JSONPlugin(object):\n    name = 'json'\n    api  = 2\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not dumps: return callback\n        def wrapper(*a, **ka):\n            try:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "TemplatePlugin",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class TemplatePlugin(object):\n    ''' This plugin applies the :func:`view` decorator to all routes with a\n        `template` config parameter. If the parameter is a tuple, the second\n        element must be a dict with additional options (e.g. `template_engine`)\n        or default variables for the template. '''\n    name = 'template'\n    api  = 2\n    def apply(self, callback, route):\n        conf = route.config.get('template')\n        if isinstance(conf, (tuple, list)) and len(conf) == 2:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "_ImportRedirect",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class _ImportRedirect(object):\n    def __init__(self, name, impmask):\n        ''' Create a virtual package that redirects imports (see PEP 302). '''\n        self.name = name\n        self.impmask = impmask\n        self.module = sys.modules.setdefault(name, new_module(name))\n        self.module.__dict__.update({'__file__': __file__, '__path__': [],\n                                    '__all__': [], '__loader__': self})\n        sys.meta_path.append(self)\n    def find_module(self, fullname, path=None):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "MultiDict",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class MultiDict(DictMixin):\n    \"\"\" This dict stores multiple values per key, but behaves exactly like a\n        normal dict in that it returns only the newest value for any given key.\n        There are special methods available to access the full list of values.\n    \"\"\"\n    def __init__(self, *a, **k):\n        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n    def __len__(self): return len(self.dict)\n    def __iter__(self): return iter(self.dict)\n    def __contains__(self, key): return key in self.dict",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "FormsDict",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class FormsDict(MultiDict):\n    ''' This :class:`MultiDict` subclass is used to store request form data.\n        Additionally to the normal dict-like item access methods (which return\n        unmodified data as native strings), this container also supports\n        attribute-like access to its values. Attributes are automatically de-\n        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing\n        attributes default to an empty string. '''\n    #: Encoding used for attribute values.\n    input_encoding = 'utf8'\n    #: If true (default), unicode strings are first encoded with `latin1`",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HeaderDict",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class HeaderDict(MultiDict):\n    \"\"\" A case-insensitive version of :class:`MultiDict` that defaults to\n        replace the old value instead of appending it. \"\"\"\n    def __init__(self, *a, **ka):\n        self.dict = {}\n        if a or ka: self.update(*a, **ka)\n    def __contains__(self, key): return _hkey(key) in self.dict\n    def __delitem__(self, key): del self.dict[_hkey(key)]\n    def __getitem__(self, key): return self.dict[_hkey(key)][-1]\n    def __setitem__(self, key, value): self.dict[_hkey(key)] = [_hval(value)]",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "WSGIHeaderDict",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class WSGIHeaderDict(DictMixin):\n    ''' This dict-like class wraps a WSGI environ dict and provides convenient\n        access to HTTP_* fields. Keys and values are native strings\n        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI\n        environment contains non-native string values, these are de- or encoded\n        using a lossless 'latin1' character set.\n        The API will remain stable even on changes to the relevant PEPs.\n        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one\n        that uses non-native strings.)\n    '''",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class ConfigDict(dict):\n    ''' A dict-like configuration storage with additional support for\n        namespaces, validators, meta-data, on_change listeners and more.\n        This storage is optimized for fast read access. Retrieving a key\n        or using non-altering dict methods (e.g. `dict.get()`) has no overhead\n        compared to a native dict.\n    '''\n    __slots__ = ('_meta', '_on_change')\n    class Namespace(DictMixin):\n        def __init__(self, config, namespace):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "AppStack",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self[-1]\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "WSGIFileWrapper",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class WSGIFileWrapper(object):\n    def __init__(self, fp, buffer_size=1024*64):\n        self.fp, self.buffer_size = fp, buffer_size\n        for attr in ('fileno', 'close', 'read', 'readlines', 'tell', 'seek'):\n            if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))\n    def __iter__(self):\n        buff, read = self.buffer_size, self.read\n        while True:\n            part = read(buff)\n            if not part: return",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "_closeiter",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class _closeiter(object):\n    ''' This only exists to be able to attach a .close method to iterators that\n        do not support attribute assignment (most of itertools). '''\n    def __init__(self, iterator, close=None):\n        self.iterator = iterator\n        self.close_callbacks = makelist(close)\n    def __iter__(self):\n        return iter(self.iterator)\n    def close(self):\n        for func in self.close_callbacks:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "ResourceManager",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class ResourceManager(object):\n    ''' This class manages a list of search paths and helps to find and open\n        application-bound resources (files).\n        :param base: default value for :meth:`add_path` calls.\n        :param opener: callable used to open resources.\n        :param cachemode: controls which lookups are cached. One of 'all',\n                         'found' or 'none'.\n    '''\n    def __init__(self, base='./', opener=open, cachemode='all'):\n        self.opener = open",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "FileUpload",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class FileUpload(object):\n    def __init__(self, fileobj, name, filename, headers=None):\n        ''' Wrapper for file uploads. '''\n        #: Open file(-like) object (BytesIO buffer or temporary file)\n        self.file = fileobj\n        #: Name of the upload form field\n        self.name = name\n        #: Raw filename as sent by the client (may contain unsafe characters)\n        self.raw_filename = filename\n        #: A :class:`HeaderDict` with additional headers (e.g. content-type)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "ServerAdapter",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class ServerAdapter(object):\n    quiet = False\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n    def run(self, handler): # pragma: no cover\n        pass\n    def __repr__(self):\n        args = ', '.join(['%s=%s'%(k,repr(v)) for k, v in self.options.items()])",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "CGIServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class CGIServer(ServerAdapter):\n    quiet = True\n    def run(self, handler): # pragma: no cover\n        from wsgiref.handlers import CGIHandler\n        def fixed_environ(environ, start_response):\n            environ.setdefault('PATH_INFO', '')\n            return handler(environ, start_response)\n        CGIHandler().run(fixed_environ)\nclass FlupFCGIServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "FlupFCGIServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class FlupFCGIServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        import flup.server.fcgi\n        self.options.setdefault('bindAddress', (self.host, self.port))\n        flup.server.fcgi.WSGIServer(handler, **self.options).run()\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app): # pragma: no cover\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        from wsgiref.simple_server import make_server\n        import socket",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "WSGIRefServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class WSGIRefServer(ServerAdapter):\n    def run(self, app): # pragma: no cover\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        from wsgiref.simple_server import make_server\n        import socket\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self): # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n            def log_request(*args, **kw):\n                if not self.quiet:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "CherryPyServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class CherryPyServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        depr(\"The wsgi server part of cherrypy was split into a new \"\n             \"project called 'cheroot'. Use the 'cheroot' server \"\n             \"adapter instead of cherrypy.\")\n        from cherrypy import wsgiserver # This will fail for CherryPy >= 9\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n        certfile = self.options.get('certfile')\n        if certfile:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "CherootServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class CherootServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from cheroot import wsgi\n        from cheroot.ssl import builtin\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n        certfile = self.options.pop('certfile', None)\n        keyfile = self.options.pop('keyfile', None)\n        chainfile = self.options.pop('chainfile', None)\n        server = wsgi.Server(**self.options)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "WaitressServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class WaitressServer(ServerAdapter):\n    def run(self, handler):\n        from waitress import serve\n        serve(handler, host=self.host, port=self.port)\nclass PasteServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler, host=self.host, port=str(self.port),",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "PasteServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class PasteServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler, host=self.host, port=str(self.port),\n                         **self.options)\nclass MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "MeinheldServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server\n        server.listen((self.host, self.port))\n        server.run(handler)\nclass FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See https://github.com/william-os4y/fapws3 \"\"\"\n    def run(self, handler): # pragma: no cover\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "FapwsServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See https://github.com/william-os4y/fapws3 \"\"\"\n    def run(self, handler): # pragma: no cover\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config\n        port = self.port\n        if float(config.SERVER_IDENT[-2:]) > 0.4:\n            # fapws3 silently changed its API in 0.5\n            port = str(port)\n        evwsgi.start(self.host, port)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "TornadoServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class TornadoServer(ServerAdapter):\n    \"\"\" The super hyped asynchronous server by facebook. Untested. \"\"\"\n    def run(self, handler): # pragma: no cover\n        import tornado.wsgi, tornado.httpserver, tornado.ioloop\n        container = tornado.wsgi.WSGIContainer(handler)\n        server = tornado.httpserver.HTTPServer(container)\n        server.listen(port=self.port,address=self.host)\n        tornado.ioloop.IOLoop.instance().start()\nclass AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "AppEngineServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"\n    quiet = True\n    def run(self, handler):\n        from google.appengine.ext.webapp import util\n        # A main() function in the handler script enables 'App Caching'.\n        # Lets makes sure it is there. This _really_ improves performance.\n        module = sys.modules.get('__main__')\n        if module and not hasattr(module, 'main'):\n            module.main = lambda: util.run_wsgi_app(handler)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "TwistedServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class TwistedServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from twisted.web import server, wsgi\n        from twisted.python.threadpool import ThreadPool\n        from twisted.internet import reactor\n        thread_pool = ThreadPool()\n        thread_pool.start()\n        reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)\n        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "DieselServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class DieselServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from diesel.protocols.wsgi import WSGIApplication\n        app = WSGIApplication(handler, port=self.port)\n        app.run()\nclass GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n        * `fast` (default: False) uses libevent's http server, but has some\n          issues: No streaming, no pipelining, no SSL.",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "GeventServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n        * `fast` (default: False) uses libevent's http server, but has some\n          issues: No streaming, no pipelining, no SSL.\n        * See gevent.wsgi.WSGIServer() documentation for more options.\n    \"\"\"\n    def run(self, handler):\n        from gevent import pywsgi, local\n        if not isinstance(threading.local(), local.local):\n            msg = \"Bottle requires gevent.monkey.patch_all() (before import)\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "GeventSocketIOServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class GeventSocketIOServer(ServerAdapter):\n    def run(self,handler):\n        from socketio import server\n        address = (self.host, self.port)\n        server.SocketIOServer(address, handler, **self.options).serve_forever()\nclass GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n    def run(self, handler):\n        from gunicorn.app.base import Application\n        config = {'bind': \"%s:%d\" % (self.host, int(self.port))}",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "GunicornServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n    def run(self, handler):\n        from gunicorn.app.base import Application\n        config = {'bind': \"%s:%d\" % (self.host, int(self.port))}\n        config.update(self.options)\n        class GunicornApplication(Application):\n            def init(self, parser, opts, args):\n                return config\n            def load(self):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "EventletServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class EventletServer(ServerAdapter):\n    \"\"\" Untested \"\"\"\n    def run(self, handler):\n        from eventlet import wsgi, listen\n        try:\n            wsgi.server(listen((self.host, self.port)), handler,\n                        log_output=(not self.quiet))\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            wsgi.server(listen((self.host, self.port)), handler)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "RocketServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class RocketServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    def run(self, handler):\n        from rocket import Rocket\n        server = Rocket((self.host, self.port), 'wsgi', { 'wsgi_app' : handler })\n        server.start()\nclass BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n    def run(self, handler):\n        from bjoern import run",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "BjoernServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n    def run(self, handler):\n        from bjoern import run\n        run(handler, self.host, self.port)\nclass AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                CherootServer, WSGIRefServer]\n    def run(self, handler):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "AutoServer",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                CherootServer, WSGIRefServer]\n    def run(self, handler):\n        for sa in self.adapters:\n            try:\n                return sa(self.host, self.port, **self.options).run(handler)\n            except ImportError:\n                pass",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "FileCheckerThread",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class FileCheckerThread(threading.Thread):\n    ''' Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets to old. '''\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n    def run(self):\n        exists = os.path.exists",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "TemplateError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class TemplateError(HTTPError):\n    def __init__(self, message):\n        HTTPError.__init__(self, 500, message)\nclass BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl','html','thtml','stpl']\n    settings = {} #used in prepare()\n    defaults = {} #used in render()\n    def __init__(self, source=None, name=None, lookup=[], encoding='utf8', **settings):\n        \"\"\" Create a new template.",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "BaseTemplate",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl','html','thtml','stpl']\n    settings = {} #used in prepare()\n    defaults = {} #used in render()\n    def __init__(self, source=None, name=None, lookup=[], encoding='utf8', **settings):\n        \"\"\" Create a new template.\n        If the source parameter (str or buffer) is missing, the name argument\n        is used to guess a template filename. Subclasses can assume that\n        self.source and/or self.filename are set. Both are strings.",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "MakoTemplate",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class MakoTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from mako.template import Template\n        from mako.lookup import TemplateLookup\n        options.update({'input_encoding':self.encoding})\n        options.setdefault('format_exceptions', bool(DEBUG))\n        lookup = TemplateLookup(directories=self.lookup, **options)\n        if self.source:\n            self.tpl = Template(self.source, lookup=lookup, **options)\n        else:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "CheetahTemplate",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class CheetahTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from Cheetah.Template import Template\n        self.context = threading.local()\n        self.context.vars = {}\n        options['searchList'] = [self.context.vars]\n        if self.source:\n            self.tpl = Template(source=self.source, **options)\n        else:\n            self.tpl = Template(file=self.filename, **options)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "Jinja2Template",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class Jinja2Template(BaseTemplate):\n    def prepare(self, filters=None, tests=None, globals={}, **kwargs):\n        from jinja2 import Environment, FunctionLoader\n        if 'prefix' in kwargs: # TODO: to be removed after a while\n            raise RuntimeError('The keyword argument `prefix` has been removed. '\n                'Use the full jinja2 environment name line_statement_prefix instead.')\n        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)\n        if filters: self.env.filters.update(filters)\n        if tests: self.env.tests.update(tests)\n        if globals: self.env.globals.update(globals)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "SimpleTemplate",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class SimpleTemplate(BaseTemplate):\n    def prepare(self, escape_func=html_escape, noescape=False, syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n    @cached_property",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "StplSyntaxError",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class StplSyntaxError(TemplateError): pass\nclass StplParser(object):\n    ''' Parser for stpl templates. '''\n    _re_cache = {} #: Cache for compiled re patterns\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # 1: All kinds of python strings (trust me, it works)\n    _re_tok = '([urbURB]?(?:\\'\\'(?!\\')|\"\"(?!\")|\\'{6}|\"{6}' \\\n               '|\\'(?:[^\\\\\\\\\\']|\\\\\\\\.)+?\\'|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)+?\"' \\\n               '|\\'{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\\'{3}' \\\n               '|\"{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\"{3}))'",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "StplParser",
        "kind": 6,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "class StplParser(object):\n    ''' Parser for stpl templates. '''\n    _re_cache = {} #: Cache for compiled re patterns\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # 1: All kinds of python strings (trust me, it works)\n    _re_tok = '([urbURB]?(?:\\'\\'(?!\\')|\"\"(?!\")|\\'{6}|\"{6}' \\\n               '|\\'(?:[^\\\\\\\\\\']|\\\\\\\\.)+?\\'|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)+?\"' \\\n               '|\\'{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\\'{3}' \\\n               '|\"{3}(?:[^\\\\\\\\]|\\\\\\\\.|\\\\n)+?\"{3}))'\n    _re_inl = _re_tok.replace('|\\\\n','') # We re-use this string pattern later",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "tob",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def tob(s, enc='utf8'):\n    return s.encode(enc) if isinstance(s, unicode) else bytes(s)\ndef touni(s, enc='utf8', err='strict'):\n    return s.decode(enc, err) if isinstance(s, bytes) else unicode(s)\ntonat = touni if py3k else tob\n# 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n# 3.1 needs a workaround.\nif py31:\n    from io import TextIOWrapper\n    class NCTextIOWrapper(TextIOWrapper):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "touni",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def touni(s, enc='utf8', err='strict'):\n    return s.decode(enc, err) if isinstance(s, bytes) else unicode(s)\ntonat = touni if py3k else tob\n# 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n# 3.1 needs a workaround.\nif py31:\n    from io import TextIOWrapper\n    class NCTextIOWrapper(TextIOWrapper):\n        def close(self): pass # Keep wrapped buffer open.\n# A bug in functools causes it to break if the wrapper is an instance method",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def update_wrapper(wrapper, wrapped, *a, **ka):\n    try: functools.update_wrapper(wrapper, wrapped, *a, **ka)\n    except AttributeError: pass\n# These helpers are used at module level and need to be defined first.\n# And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.\ndef depr(message, hard=False):\n    warnings.warn(message, DeprecationWarning, stacklevel=3)\ndef makelist(data): # This is just to handy\n    if isinstance(data, (tuple, list, set, dict)): return list(data)\n    elif data: return [data]",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "depr",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def depr(message, hard=False):\n    warnings.warn(message, DeprecationWarning, stacklevel=3)\ndef makelist(data): # This is just to handy\n    if isinstance(data, (tuple, list, set, dict)): return list(data)\n    elif data: return [data]\n    else: return []\nclass DictProperty(object):\n    ''' Property that maps to a key in a local dict-like attribute. '''\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "makelist",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def makelist(data): # This is just to handy\n    if isinstance(data, (tuple, list, set, dict)): return list(data)\n    elif data: return [data]\n    else: return []\nclass DictProperty(object):\n    ''' Property that maps to a key in a local dict-like attribute. '''\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "local_property",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def local_property(name=None):\n    if name: depr('local_property() is deprecated and will be removed.') #0.12\n    ls = threading.local()\n    def fget(self):\n        try: return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n    def fset(self, value): ls.var = value\n    def fdel(self): del ls.var\n    return property(fget, fset, fdel, 'Thread-local property')",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "abort",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def abort(code=500, text='Unknown Error.'):\n    \"\"\" Aborts execution and causes a HTTP error. \"\"\"\n    raise HTTPError(code, text)\ndef redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "redirect",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code\n    res.body = \"\"\n    res.set_header('Location', urljoin(request.url, url))\n    raise res",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "static_file",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def static_file(filename, root, mimetype='auto', download=False, charset='UTF-8'):\n    \"\"\" Open a file in a safe way and return :exc:`HTTPResponse` with status\n        code 200, 305, 403 or 404. The ``Content-Type``, ``Content-Encoding``,\n        ``Content-Length`` and ``Last-Modified`` headers are set if possible.\n        Special support for ``If-Modified-Since``, ``Range`` and ``HEAD``\n        requests.\n        :param filename: Name or path of the file to send.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Defines the content-type header (default: guess from",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def debug(mode=True):\n    \"\"\" Change the debug level.\n    There is only one debug level supported at the moment.\"\"\"\n    global DEBUG\n    if mode: warnings.simplefilter('default')\n    DEBUG = bool(mode)\ndef http_date(value):\n    if isinstance(value, (datedate, datetime)):\n        value = value.utctimetuple()\n    elif isinstance(value, (int, float)):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "http_date",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def http_date(value):\n    if isinstance(value, (datedate, datetime)):\n        value = value.utctimetuple()\n    elif isinstance(value, (int, float)):\n        value = time.gmtime(value)\n    if not isinstance(value, basestring):\n        value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n    return value\ndef parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "parse_date",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"\n    try:\n        ts = email.utils.parsedate_tz(ims)\n        return time.mktime(ts[:8] + (0,)) - (ts[9] or 0) - time.timezone\n    except (TypeError, ValueError, IndexError, OverflowError):\n        return None\ndef parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "parse_auth",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            user, pwd = touni(base64.b64decode(tob(data))).split(':',1)\n            return user, pwd\n    except (KeyError, ValueError):\n        return None\ndef parse_range_header(header, maxlen=0):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "parse_range_header",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def parse_range_header(header, maxlen=0):\n    ''' Yield (start, end) ranges parsed from a HTTP Range header. Skip\n        unsatisfiable ranges. The end index is non-inclusive.'''\n    if not header or header[:6] != 'bytes=': return\n    ranges = [r.split('-', 1) for r in header[6:].split(',') if '-' in r]\n    for start, end in ranges:\n        try:\n            if not start:  # bytes=-100    -> last 100 bytes\n                start, end = max(0, maxlen-int(end)), maxlen\n            elif not end:  # bytes=100-    -> all but the first 99 bytes",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "cookie_encode",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def cookie_encode(data, key):\n    ''' Encode and sign a pickle-able object. Return a (byte) string '''\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())\n    return tob('!') + sig + tob('?') + msg\ndef cookie_decode(data, key):\n    ''' Verify and decode an encoded string. Return an object or None.'''\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "cookie_decode",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def cookie_decode(data, key):\n    ''' Verify and decode an encoded string. Return an object or None.'''\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())):\n            return pickle.loads(base64.b64decode(msg))\n    return None\ndef cookie_is_encoded(data):\n    ''' Return True if the argument looks like a encoded cookie.'''",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "cookie_is_encoded",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def cookie_is_encoded(data):\n    ''' Return True if the argument looks like a encoded cookie.'''\n    return bool(data.startswith(tob('!')) and tob('?') in data)\ndef html_escape(string):\n    ''' Escape HTML special characters ``&<>`` and quotes ``'\"``. '''\n    return string.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')\\\n                 .replace('\"','&quot;').replace(\"'\",'&#039;')\ndef html_quote(string):\n    ''' Escape and quote a string to be used as an HTTP attribute.'''\n    return '\"%s\"' % html_escape(string).replace('\\n','&#10;')\\",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "html_escape",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def html_escape(string):\n    ''' Escape HTML special characters ``&<>`` and quotes ``'\"``. '''\n    return string.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')\\\n                 .replace('\"','&quot;').replace(\"'\",'&#039;')\ndef html_quote(string):\n    ''' Escape and quote a string to be used as an HTTP attribute.'''\n    return '\"%s\"' % html_escape(string).replace('\\n','&#10;')\\\n                    .replace('\\r','&#13;').replace('\\t','&#9;')\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "html_quote",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def html_quote(string):\n    ''' Escape and quote a string to be used as an HTTP attribute.'''\n    return '\"%s\"' % html_escape(string).replace('\\n','&#10;')\\\n                    .replace('\\r','&#13;').replace('\\t','&#9;')\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "yieldroutes",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'\n        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\n        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n    \"\"\"\n    path = '/' + func.__name__.replace('__','/').lstrip('/')",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "path_shift",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def path_shift(script_name, path_info, shift=1):\n    ''' Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n        :return: The modified paths.\n        :param script_name: The SCRIPT_NAME path.\n        :param script_name: The PATH_INFO path.\n        :param shift: The number of path fragments to shift. May be negative to\n          change the shift direction. (default: 1)\n    '''\n    if shift == 0: return script_name, path_info\n    pathlist = path_info.strip('/').split('/')",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "auth_basic",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def auth_basic(check, realm=\"private\", text=\"Access denied\"):\n    ''' Callback decorator to require HTTP auth (basic).\n        TODO: Add route(check_auth=...) parameter. '''\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*a, **ka):\n            user, password = request.auth or (None, None)\n            if user is None or not check(user, password):\n                err = HTTPError(401, text)\n                err.add_header('WWW-Authenticate', 'Basic realm=\"%s\"' % realm)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "make_default_app_wrapper",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def make_default_app_wrapper(name):\n    ''' Return a callable that relays calls to the current default app. '''\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n    return wrapper\nroute     = make_default_app_wrapper('route')\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def load(target, **namespace):\n    \"\"\" Import a module or fetch an object from a module.\n        * ``package.module`` returns `module` as a module object.\n        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.\n        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.\n        The last form accepts not only function calls, but any type of\n        expression. Keyword arguments passed to this function are available as\n        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``\n    \"\"\"\n    module, target = target.split(\":\", 1) if ':' in target else (target, None)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "load_app",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN; NORUN, nr_old = True, NORUN\n    try:\n        tmp = default_app.push() # Create a new \"default application\"\n        rv = load(target) # Import the target module\n        return rv if callable(rv) else tmp\n    finally:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def run(app=None, server='wsgiref', host='127.0.0.1', port=8080,\n        interval=1, reloader=False, quiet=False, plugins=None,\n        debug=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "template",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def template(*args, **kwargs):\n    '''\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    '''\n    tpl = args[0] if args else None\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "view",
        "kind": 2,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "def view(tpl_name, **defaults):\n    ''' Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    '''\n    def decorator(func):",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "__author__ = 'Marcel Hellkamp'\n__version__ = '0.12.25'\n__license__ = 'MIT'\n# The gevent server adapter needs to patch some modules before they are imported\n# This is why we parse the commandline parameters here but handle them later\nif __name__ == '__main__':\n    from optparse import OptionParser\n    _cmd_parser = OptionParser(usage=\"usage: %prog [options] package.module:app\")\n    _opt = _cmd_parser.add_option\n    _opt(\"--version\", action=\"store_true\", help=\"show version number.\")",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "__version__ = '0.12.25'\n__license__ = 'MIT'\n# The gevent server adapter needs to patch some modules before they are imported\n# This is why we parse the commandline parameters here but handle them later\nif __name__ == '__main__':\n    from optparse import OptionParser\n    _cmd_parser = OptionParser(usage=\"usage: %prog [options] package.module:app\")\n    _opt = _cmd_parser.add_option\n    _opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    _opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "__license__",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "__license__ = 'MIT'\n# The gevent server adapter needs to patch some modules before they are imported\n# This is why we parse the commandline parameters here but handle them later\nif __name__ == '__main__':\n    from optparse import OptionParser\n    _cmd_parser = OptionParser(usage=\"usage: %prog [options] package.module:app\")\n    _opt = _cmd_parser.add_option\n    _opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    _opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")\n    _opt(\"-s\", \"--server\", default='wsgiref', help=\"use SERVER as backend.\")",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "py3k",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "py3k = py >= (3, 0, 0)\npy25 = py <  (2, 6, 0)\npy31 = (3, 1, 0) <= py < (3, 2, 0)\n# Workaround for the missing \"as\" keyword in py3k.\ndef _e(): return sys.exc_info()[1]\n# Workaround for the \"print is a keyword/function\" Python 2/3 dilemma\n# and a fallback for mod_wsgi (resticts stdout/err attribute access)\ntry:\n    _stdout, _stderr = sys.stdout.write, sys.stderr.write\nexcept IOError:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "py25",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "py25 = py <  (2, 6, 0)\npy31 = (3, 1, 0) <= py < (3, 2, 0)\n# Workaround for the missing \"as\" keyword in py3k.\ndef _e(): return sys.exc_info()[1]\n# Workaround for the \"print is a keyword/function\" Python 2/3 dilemma\n# and a fallback for mod_wsgi (resticts stdout/err attribute access)\ntry:\n    _stdout, _stderr = sys.stdout.write, sys.stderr.write\nexcept IOError:\n    _stdout = lambda x: sys.stdout.write(x)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "py31",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "py31 = (3, 1, 0) <= py < (3, 2, 0)\n# Workaround for the missing \"as\" keyword in py3k.\ndef _e(): return sys.exc_info()[1]\n# Workaround for the \"print is a keyword/function\" Python 2/3 dilemma\n# and a fallback for mod_wsgi (resticts stdout/err attribute access)\ntry:\n    _stdout, _stderr = sys.stdout.write, sys.stderr.write\nexcept IOError:\n    _stdout = lambda x: sys.stdout.write(x)\n    _stderr = lambda x: sys.stderr.write(x)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "tonat",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "tonat = touni if py3k else tob\n# 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n# 3.1 needs a workaround.\nif py31:\n    from io import TextIOWrapper\n    class NCTextIOWrapper(TextIOWrapper):\n        def close(self): pass # Keep wrapped buffer open.\n# A bug in functools causes it to break if the wrapper is an instance method\ndef update_wrapper(wrapper, wrapped, *a, **ka):\n    try: functools.update_wrapper(wrapper, wrapped, *a, **ka)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "Request",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "Request = BaseRequest\nResponse = BaseResponse\nclass HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n    def apply(self, response):\n        response._status_code = self._status_code\n        response._status_line = self._status_line\n        response._headers = self._headers\n        response._cookies = self._cookies",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "Response = BaseResponse\nclass HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n    def apply(self, response):\n        response._status_code = self._status_code\n        response._status_line = self._status_line\n        response._headers = self._headers\n        response._cookies = self._cookies\n        response.body = self.body",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "uninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n###############################################################################\n# Server Adapter ###############################################################\n###############################################################################\nclass ServerAdapter(object):\n    quiet = False\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "server_names",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "server_names = {\n    'cgi': CGIServer,\n    'flup': FlupFCGIServer,\n    'wsgiref': WSGIRefServer,\n    'waitress': WaitressServer,\n    'cherrypy': CherryPyServer,\n    'cheroot': CherootServer,\n    'paste': PasteServer,\n    'fapws3': FapwsServer,\n    'tornado': TornadoServer,",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "_debug",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "_debug = debug\ndef run(app=None, server='wsgiref', host='127.0.0.1', port=8080,\n        interval=1, reloader=False, quiet=False, plugins=None,\n        debug=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "mako_template",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "mako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template, template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\ndef view(tpl_name, **defaults):\n    ''' Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "cheetah_template",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "cheetah_template = functools.partial(template, template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\ndef view(tpl_name, **defaults):\n    ''' Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "jinja2_template",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "jinja2_template = functools.partial(template, template_adapter=Jinja2Template)\ndef view(tpl_name, **defaults):\n    ''' Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    '''",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "mako_view",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "mako_view = functools.partial(view, template_adapter=MakoTemplate)\ncheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "cheetah_view",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "cheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "jinja2_view",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "jinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "TEMPLATE_PATH",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "TEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses\nHTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "TEMPLATES",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "TEMPLATES = {}\nDEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses\nHTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "DEBUG = False\nNORUN = False # If set, run() does nothing. Used by load_app()\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses\nHTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "NORUN",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "NORUN = False # If set, run() does nothing. Used by load_app()\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses\nHTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTP_CODES",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "HTTP_CODES = httplib.responses\nHTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTP_CODES[418]",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "HTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\nHTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTP_CODES[422]",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "HTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTP_CODES[428]",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "HTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTP_CODES[429]",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "HTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTP_CODES[431]",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "HTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "HTTP_CODES[511]",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "HTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "_HTTP_STATUS_LINES",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "ERROR_PAGE_TEMPLATE",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "ERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, HTTP_CODES, request, touni\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">\n              html {background-color: #eee; font-family: sans;}\n              body {background-color: #fff; border: 1px solid #ddd;",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "request = LocalRequest()\n#: A thread-safe instance of :class:`LocalResponse`. It is used to change the\n#: HTTP response for the *current* request.\nresponse = LocalResponse()\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n# Initialize app stack (create first empty Bottle app)\n# BC: 0.6.4 and needed for run()\napp = default_app = AppStack()\napp.push()",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "response = LocalResponse()\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n# Initialize app stack (create first empty Bottle app)\n# BC: 0.6.4 and needed for run()\napp = default_app = AppStack()\napp.push()\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else __name__+\".ext\", 'bottle_%s').module",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "local",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "local = threading.local()\n# Initialize app stack (create first empty Bottle app)\n# BC: 0.6.4 and needed for run()\napp = default_app = AppStack()\napp.push()\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else __name__+\".ext\", 'bottle_%s').module\nif __name__ == '__main__':\n    opt, args, parser = _cmd_options, _cmd_args, _cmd_parser",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "app = default_app = AppStack()\napp.push()\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else __name__+\".ext\", 'bottle_%s').module\nif __name__ == '__main__':\n    opt, args, parser = _cmd_options, _cmd_args, _cmd_parser\n    if opt.version:\n        _stdout('Bottle %s\\n'%__version__)\n        sys.exit(0)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "ext",
        "kind": 5,
        "importPath": "venv.Scripts.bottle",
        "description": "venv.Scripts.bottle",
        "peekOfCode": "ext = _ImportRedirect('bottle.ext' if __name__ == '__main__' else __name__+\".ext\", 'bottle_%s').module\nif __name__ == '__main__':\n    opt, args, parser = _cmd_options, _cmd_args, _cmd_parser\n    if opt.version:\n        _stdout('Bottle %s\\n'%__version__)\n        sys.exit(0)\n    if not args:\n        parser.print_help()\n        _stderr('\\nError: No application specified.\\n')\n        sys.exit(1)",
        "detail": "venv.Scripts.bottle",
        "documentation": {}
    },
    {
        "label": "firestore_adminCallTransformer",
        "kind": 6,
        "importPath": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "description": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "peekOfCode": "class firestore_adminCallTransformer(cst.CSTTransformer):\n    CTRL_PARAMS: Tuple[str] = ('retry', 'timeout', 'metadata')\n    METHOD_TO_PARAMS: Dict[str, Tuple[str]] = {\n        'create_backup_schedule': ('parent', 'backup_schedule', ),\n        'create_database': ('parent', 'database', 'database_id', ),\n        'create_index': ('parent', 'index', ),\n        'delete_backup': ('name', ),\n        'delete_backup_schedule': ('name', ),\n        'delete_database': ('name', 'etag', ),\n        'delete_index': ('name', ),",
        "detail": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "description": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "peekOfCode": "def partition(\n    predicate: Callable[[Any], bool],\n    iterator: Sequence[Any]\n) -> Tuple[List[Any], List[Any]]:\n    \"\"\"A stable, out-of-place partition.\"\"\"\n    results = ([], [])\n    for i in iterator:\n        results[int(predicate(i))].append(i)\n    # Returns trueList, falseList\n    return results[1], results[0]",
        "detail": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "documentation": {}
    },
    {
        "label": "fix_files",
        "kind": 2,
        "importPath": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "description": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "peekOfCode": "def fix_files(\n    in_dir: pathlib.Path,\n    out_dir: pathlib.Path,\n    *,\n    transformer=firestore_adminCallTransformer(),\n):\n    \"\"\"Duplicate the input dir to the output dir, fixing file method calls.\n    Preconditions:\n    * in_dir is a real directory\n    * out_dir is a real, empty directory",
        "detail": "venv.Scripts.fixup_firestore_admin_v1_keywords",
        "documentation": {}
    },
    {
        "label": "firestoreCallTransformer",
        "kind": 6,
        "importPath": "venv.Scripts.fixup_firestore_v1_keywords",
        "description": "venv.Scripts.fixup_firestore_v1_keywords",
        "peekOfCode": "class firestoreCallTransformer(cst.CSTTransformer):\n    CTRL_PARAMS: Tuple[str] = ('retry', 'timeout', 'metadata')\n    METHOD_TO_PARAMS: Dict[str, Tuple[str]] = {\n        'batch_get_documents': ('database', 'documents', 'mask', 'transaction', 'new_transaction', 'read_time', ),\n        'batch_write': ('database', 'writes', 'labels', ),\n        'begin_transaction': ('database', 'options', ),\n        'commit': ('database', 'writes', 'transaction', ),\n        'create_document': ('parent', 'collection_id', 'document', 'document_id', 'mask', ),\n        'delete_document': ('name', 'current_document', ),\n        'get_document': ('name', 'mask', 'transaction', 'read_time', ),",
        "detail": "venv.Scripts.fixup_firestore_v1_keywords",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "venv.Scripts.fixup_firestore_v1_keywords",
        "description": "venv.Scripts.fixup_firestore_v1_keywords",
        "peekOfCode": "def partition(\n    predicate: Callable[[Any], bool],\n    iterator: Sequence[Any]\n) -> Tuple[List[Any], List[Any]]:\n    \"\"\"A stable, out-of-place partition.\"\"\"\n    results = ([], [])\n    for i in iterator:\n        results[int(predicate(i))].append(i)\n    # Returns trueList, falseList\n    return results[1], results[0]",
        "detail": "venv.Scripts.fixup_firestore_v1_keywords",
        "documentation": {}
    },
    {
        "label": "fix_files",
        "kind": 2,
        "importPath": "venv.Scripts.fixup_firestore_v1_keywords",
        "description": "venv.Scripts.fixup_firestore_v1_keywords",
        "peekOfCode": "def fix_files(\n    in_dir: pathlib.Path,\n    out_dir: pathlib.Path,\n    *,\n    transformer=firestoreCallTransformer(),\n):\n    \"\"\"Duplicate the input dir to the output dir, fixing file method calls.\n    Preconditions:\n    * in_dir is a real directory\n    * out_dir is a real, empty directory",
        "detail": "venv.Scripts.fixup_firestore_v1_keywords",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except IOError:\n                pass\n        tee_f.write(what)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info[0],\n        sys.version_info[1],\n        suffix,",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(\"-> %s\\\\%s[%s]=%r\" % (root_key_name, key_name, value_name, value))\n        finally:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(\"-> DELETE %s\\\\%s[%s]\" % (root_key_name, key_name, value_name))\n        finally:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n        like file_created to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(\"Failed to unregister COM objects: %s\" % (why,))\n    try:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location):\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError('Path \"{}\" does not exist!'.format(location))\n    return location\ndef main():\n    import argparse\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    import argparse\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python pywin32_postinstall.py -install\n    If you installed pywin32 via a .exe installer, this should be run\n    automatically after installation, but if it fails you can run it again.\n    If you installed pywin32 via PIP, you almost certainly need to run this to",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(os.path.join(tempfile.gettempdir(), \"pywin32_postinstall.log\"), \"w\")\nclass Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except IOError:\n                pass",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to Python23\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to Python23\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created\n    is_bdist_wininst = True",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to Python23\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created\n    is_bdist_wininst = True\nexcept NameError:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(\"*** Test script '%s' exited with %s\" % (script, result.returncode))\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [this_dir] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "this_dir",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "this_dir = os.path.dirname(__file__)\nsite_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "ExecuteCode",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def ExecuteCode(code_str: str) -> None:\n  try:\n    exec(code_str)\n  except Exception as e:\n    print('Error in ExecuteCode function(Execute.py), code contained in input string has wrong syntax OR wrong datatype argument. Error:', e)\n#? Some important inits\neel.init(\"Interface\")\nmixer.init()\n@eel.expose\ndef AddToUserHistory(data, date, soul, varient=\"default\"):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "AddToUserHistory",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def AddToUserHistory(data, date, soul, varient=\"default\"):\n  if varient == \"default\":\n    print(\"Adding to history\")\n    with open(\"Interface/History/History.json\", \"r\") as f:\n      history = json.load(f)\n    with open(\"Interface/History/History.json\", \"w\") as f:\n      history[str(soul)][\"history\"].append({\n        \"Data\": data,\n        \"Date\": str(date),\n        \"Role\": \"user\"",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "AddToUserHistoryImage",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def AddToUserHistoryImage(data, date, soul, role, img1, img2, img3, img4, varient=\"default\"):\n  with open(\"Interface/History/History.json\", \"r\") as f:\n    history = json.load(f)\n  if varient == \"default\":\n    with open(\"Interface/History/History.json\", \"w\") as f:\n      history[str(soul)][\"history\"].append({\n        \"Data\": data,\n        \"Date\": date,\n        \"Role\": role,\n        \"Image\": [",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "DeletePreviousElementFromUserHistory",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def DeletePreviousElementFromUserHistory(soul):\n  with open(\"Interface/History/History.json\", \"r\") as f:\n    history = json.load(f)\n  with open(\"Interface/History/History.json\", \"w\") as f:\n    history[str(soul)][\"history\"].pop()\n    json.dump(history, f, indent=2)\n@eel.expose\ndef RestoreHistory(soul):\n  print(\"Restoring history for \", soul)\n  with open(\"Interface/History/History.json\", \"r\") as f:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "RestoreHistory",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def RestoreHistory(soul):\n  print(\"Restoring history for \", soul)\n  with open(\"Interface/History/History.json\", \"r\") as f:\n    history = json.load(f)\n    # print(history)\n    return history[str(soul)][\"history\"]  \ndef Return_Output(code, soul):\n  speak_statements = re.findall(r'Speak\\(\"(.*?)\"\\)', code)\n  single_string = \" \".join(speak_statements)\n  with open(\"Interface/History/History.json\", \"r\") as f:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "Return_Output",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def Return_Output(code, soul):\n  speak_statements = re.findall(r'Speak\\(\"(.*?)\"\\)', code)\n  single_string = \" \".join(speak_statements)\n  with open(\"Interface/History/History.json\", \"r\") as f:\n    history = json.load(f)\n  history[str(soul)][\"history\"].append({\n    \"Data\": single_string,\n    \"Date\": time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime()),\n    \"Role\": \"bot\"\n  })",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "ChangeVoice",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def ChangeVoice(voice): \n  with open(\"Database/Voice/voice.json\", \"w\") as f:\n    json.dump({\"Voice\": voice}, f, indent=2)\n# ChangeVoice(\"en-US-SteffanNeural\")\n#? Global Vars\nMainExeStarted = False\nChatDissabled = False\nSpeaking = False\nGenResponse = False\nSoul = 1",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "Speak",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def Speak(data):\n  with open(\"Interface/History/History.json\", \"r\") as f:\n    history = json.load(f)\n  history[str(Soul)][\"history\"].append({\n    \"Data\": data,\n    \"Date\": time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime()),\n    \"Role\": \"bot\"\n  })\n  with open(\"Interface/History/History.json\", \"w\") as f:\n    json.dump(history, f, indent=2)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "ChangeGlobalVars",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def ChangeGlobalVars(Var, Value):\n  global MainExeStarted, ChatDissabled, Speaking, GenResponse, SelectedSoul\n  if Var == \"MainExeStarted\": MainExeStarted = Value\n  if Var == \"ChatDissabled\": ChatDissabled = Value\n  if Var == \"Speaking\": Speaking = Value\n  if Var == \"GenResponse\": GenResponse = Value\n  if Var == \"SelectedSoul\": SelectedSoul = Value\n  if Var == \"Exit\": \n    with Exit.get_lock():\n      Exit.value = Value",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "RefreshGlobalVars",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def RefreshGlobalVars():\n  return [\n    {\"Var\": \"MainExeStarted\", \"Value\": MainExeStarted},\n    {\"Var\": \"ChatDissabled\", \"Value\": ChatDissabled},\n    {\"Var\": \"Speaking\", \"Value\": Speaking},\n    {\"Var\": \"GenResponse\", \"Value\": GenResponse},\n    {\"Var\": \"SelectedSoul\", \"Value\": SelectedSoul},\n    {\"Var\": \"Exit\", \"Value\": Exit.value}\n  ]\n#? Recieving Image from Firebase - Functions",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "InititaliseFirebase",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def InititaliseFirebase(cred_json_filepath, db_url, storage_bucket):\n  cred = credentials.Certificate(cred_json_filepath)\n  firebase_admin.initialize_app(cred, {\n    'storageBucket': storage_bucket,\n    'databaseURL': db_url\n  })\ndef DownloadImage(image_url, filename=\"DownloadedImage.jpg\"):\n  print(\"#LOG: Trying to download image...\")\n  response = requests.get(image_url)\n  if response.status_code == 200:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "DownloadImage",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def DownloadImage(image_url, filename=\"DownloadedImage.jpg\"):\n  print(\"#LOG: Trying to download image...\")\n  response = requests.get(image_url)\n  if response.status_code == 200:\n    with open(filename, 'wb') as f:\n      f.write(response.content)\n    print(\"#LOG: Image downloaded successfully!\")\n  else:\n    print(f\"#LOG: Failed to download the image. Status code: {response.status_code}\")\n  return filename",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "DeleteImagesFromFirebase",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def DeleteImagesFromFirebase(directory):\n  bucket = storage.bucket()\n  blobs = bucket.list_blobs(prefix=directory)\n  for blob in blobs:\n    try:\n      blob.delete()\n      print(f\"Deleted image from Firebase Storage at: {blob.name}\")\n    except Exception as e:\n      print(f\"Failed to delete image from Firebase Storage at: {blob.name}. Error: {e}\")\n@eel.expose",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "PPPrint",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def PPPrint(data):\n  print(\"💻 JS: {data}\")\n@eel.expose\ndef Terminate():\n  with Exit.get_lock():\n    Exit.value = True\n  os._exit(0)\ndef close(page, sockets_still_open):\n  print(\"Page is closing...\")\ndef ImageFirebaseLink(exit_flag, db_url=DB_URL, cred_json_filepath=Cred_JSON_Filepath):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "Terminate",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def Terminate():\n  with Exit.get_lock():\n    Exit.value = True\n  os._exit(0)\ndef close(page, sockets_still_open):\n  print(\"Page is closing...\")\ndef ImageFirebaseLink(exit_flag, db_url=DB_URL, cred_json_filepath=Cred_JSON_Filepath):\n  storage_bucket = storageBucket\n  InititaliseFirebase(cred_json_filepath, db_url, storage_bucket)\n  ref = db.reference('/Link')",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "close",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def close(page, sockets_still_open):\n  print(\"Page is closing...\")\ndef ImageFirebaseLink(exit_flag, db_url=DB_URL, cred_json_filepath=Cred_JSON_Filepath):\n  storage_bucket = storageBucket\n  InititaliseFirebase(cred_json_filepath, db_url, storage_bucket)\n  ref = db.reference('/Link')\n  print(\"#LOG: Waiting for the image link to be uploaded...\")\n  while not exit_flag.value:\n    current_value = ref.get()\n    if current_value != '':",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "ImageFirebaseLink",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def ImageFirebaseLink(exit_flag, db_url=DB_URL, cred_json_filepath=Cred_JSON_Filepath):\n  storage_bucket = storageBucket\n  InititaliseFirebase(cred_json_filepath, db_url, storage_bucket)\n  ref = db.reference('/Link')\n  print(\"#LOG: Waiting for the image link to be uploaded...\")\n  while not exit_flag.value:\n    current_value = ref.get()\n    if current_value != '':\n      print(f'#LOG: Current value in the database: {current_value}')\n      ref.set('')  # Reset the database reference",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "funcVoiceExeProcess",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def funcVoiceExeProcess(exit_flag): \n  SpeakFunc(\"You can now speak, Sir.\")\n  while not exit_flag.value: \n    print(\"\\nSpeak now\")\n    try:\n      porcupine = pvporcupine.create(keywords=[\"jarvis\"])\n      pa = pyaudio.PyAudio()\n      audio_stream = pa.open(\n        rate=porcupine.sample_rate,\n        channels=1,",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "funcGUIprocess",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def funcGUIprocess(): \n  toast = Notification(app_id=\"Jarvis\", title=\"Jarvis is Up and Ready.\", msg=\"Sir, your personal assistant Jarvis is up and is willing to do anything you want.\", duration=\"short\", icon=f\"{os.getcwd()}/Assets/Images/Jarvis.png\")\n  toast.show()\n  VoiceExeProcess = multiprocessing.Process(target=funcVoiceExeProcess, args=(Exit,))\n  VoiceExeProcess.start()\n  ImageRecieveProcess = multiprocessing.Process(target=ImageFirebaseLink, args=(Exit,))\n  ImageRecieveProcess.start()\n  try:\n    eel.start(\"index.html\", position=(0, 0), close_callback=close, block=True, size=(1500, 1200), port=8080)\n  except Exception as e:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "MainExeStarted",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "MainExeStarted = False\nChatDissabled = False\nSpeaking = False\nGenResponse = False\nSoul = 1\nSelectedSoul = \"\"\nExit = multiprocessing.Value('b', False)  #? Using a multiprocessing.Value for the shared Exit flag.\n#  = multiprocessing.Value('b', False)  \n#? Local Vars\nVoiceExeProcess = None",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "ChatDissabled",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "ChatDissabled = False\nSpeaking = False\nGenResponse = False\nSoul = 1\nSelectedSoul = \"\"\nExit = multiprocessing.Value('b', False)  #? Using a multiprocessing.Value for the shared Exit flag.\n#  = multiprocessing.Value('b', False)  \n#? Local Vars\nVoiceExeProcess = None\naudio_stream = None",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "Speaking",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "Speaking = False\nGenResponse = False\nSoul = 1\nSelectedSoul = \"\"\nExit = multiprocessing.Value('b', False)  #? Using a multiprocessing.Value for the shared Exit flag.\n#  = multiprocessing.Value('b', False)  \n#? Local Vars\nVoiceExeProcess = None\naudio_stream = None\nporcupine = None",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "GenResponse",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "GenResponse = False\nSoul = 1\nSelectedSoul = \"\"\nExit = multiprocessing.Value('b', False)  #? Using a multiprocessing.Value for the shared Exit flag.\n#  = multiprocessing.Value('b', False)  \n#? Local Vars\nVoiceExeProcess = None\naudio_stream = None\nporcupine = None\npa = None",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "Soul",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "Soul = 1\nSelectedSoul = \"\"\nExit = multiprocessing.Value('b', False)  #? Using a multiprocessing.Value for the shared Exit flag.\n#  = multiprocessing.Value('b', False)  \n#? Local Vars\nVoiceExeProcess = None\naudio_stream = None\nporcupine = None\npa = None\n#? Import Variables",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "SelectedSoul",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "SelectedSoul = \"\"\nExit = multiprocessing.Value('b', False)  #? Using a multiprocessing.Value for the shared Exit flag.\n#  = multiprocessing.Value('b', False)  \n#? Local Vars\nVoiceExeProcess = None\naudio_stream = None\nporcupine = None\npa = None\n#? Import Variables\nwith open('api_keys.json', 'r') as f:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "Exit",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "Exit = multiprocessing.Value('b', False)  #? Using a multiprocessing.Value for the shared Exit flag.\n#  = multiprocessing.Value('b', False)  \n#? Local Vars\nVoiceExeProcess = None\naudio_stream = None\nporcupine = None\npa = None\n#? Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "VoiceExeProcess",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "VoiceExeProcess = None\naudio_stream = None\nporcupine = None\npa = None\n#? Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  gemini_api = ld[\"gemini1\"]\n  news_api = ld[\"newsapi\"]\n  DB_URL = ld[\"DB_URL\"]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "audio_stream",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "audio_stream = None\nporcupine = None\npa = None\n#? Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  gemini_api = ld[\"gemini1\"]\n  news_api = ld[\"newsapi\"]\n  DB_URL = ld[\"DB_URL\"]\n  Cred_JSON_Filepath = ld[\"Cred_JSON_Filepath\"]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "porcupine",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "porcupine = None\npa = None\n#? Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  gemini_api = ld[\"gemini1\"]\n  news_api = ld[\"newsapi\"]\n  DB_URL = ld[\"DB_URL\"]\n  Cred_JSON_Filepath = ld[\"Cred_JSON_Filepath\"]\n  storageBucket = ld[\"storage_bucket\"]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "pa",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "pa = None\n#? Import Variables\nwith open('api_keys.json', 'r') as f:\n  ld = json.loads(f.read())\n  gemini_api = ld[\"gemini1\"]\n  news_api = ld[\"newsapi\"]\n  DB_URL = ld[\"DB_URL\"]\n  Cred_JSON_Filepath = ld[\"Cred_JSON_Filepath\"]\n  storageBucket = ld[\"storage_bucket\"]\ndef Speak(data):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "toSayWhenRecievedFile",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "toSayWhenRecievedFile = [\n  \"Received a file, Sir.\",\n  \"I have received a file, Sir.\",\n  \"Opening a file that I received, Sir.\",\n  \"A new file has arrived, Sir.\",\n  \"I've successfully obtained a file, Sir.\",\n  \"File received, proceeding to open it, Sir.\",\n  \"The file has been acquired, Sir.\",\n  \"A file has been added to our system, Sir.\",\n  \"A document has been delivered, Sir.\",",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "googleSearch",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def googleSearch(query):\n  search_url = f\"https://www.google.com/search?q={query}\"\n  webbrowser.open(search_url)\ndef getWeather(location):\n  try:\n    search_url = f\"https://www.google.com/search?q=weather+{location.replace(' ', '+')}\"\n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n    }\n    response = requests.get(search_url, headers=headers)",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getWeather",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getWeather(location):\n  try:\n    search_url = f\"https://www.google.com/search?q=weather+{location.replace(' ', '+')}\"\n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n    }\n    response = requests.get(search_url, headers=headers)\n    soup = BeautifulSoup(response.text, 'html.parser')\n    temperature = soup.find(\"span\", attrs={\"id\": \"wob_tm\"}).text\n    description = soup.find(\"span\", attrs={\"id\": \"wob_dc\"}).text",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "sendWhatsApp",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def sendWhatsApp(contact_number, message):\n  try: pywhatkit.sendwhatmsg_instantly(phone_no=f\"+91{contact_number}\", message=message, tab_close=True)\n  except: Speak(\"Couldn't send the message.\")\ndef playMusic(song_name):\n  import pywhatkit\n  pywhatkit.playonyt(song_name)\ndef getTodayDate():\n  return datetime.now().strftime(\"%Y-%m-%d\")\ndef getSystemInfo(info_type):\n  if info_type == \"CPU\":",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "playMusic",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def playMusic(song_name):\n  import pywhatkit\n  pywhatkit.playonyt(song_name)\ndef getTodayDate():\n  return datetime.now().strftime(\"%Y-%m-%d\")\ndef getSystemInfo(info_type):\n  if info_type == \"CPU\":\n    return f\"{psutil.cpu_percent(interval=1)}%\"\n  elif info_type == \"RAM\":\n    ram = psutil.virtual_memory()",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getTodayDate",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getTodayDate():\n  return datetime.now().strftime(\"%Y-%m-%d\")\ndef getSystemInfo(info_type):\n  if info_type == \"CPU\":\n    return f\"{psutil.cpu_percent(interval=1)}%\"\n  elif info_type == \"RAM\":\n    ram = psutil.virtual_memory()\n    return f\"{ram.percent}%\"\n  elif info_type == \"DISK\":\n    disk = psutil.disk_usage('/')",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getSystemInfo",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getSystemInfo(info_type):\n  if info_type == \"CPU\":\n    return f\"{psutil.cpu_percent(interval=1)}%\"\n  elif info_type == \"RAM\":\n    ram = psutil.virtual_memory()\n    return f\"{ram.percent}%\"\n  elif info_type == \"DISK\":\n    disk = psutil.disk_usage('/')\n    return f\"{disk.percent}%\"\n  elif info_type == \"BATTERY\":",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getCurrentTime",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getCurrentTime():\n  return datetime.now().strftime(\"%H:%M:%S\")\ndef getCurrentDay():\n  return datetime.now().strftime(\"%A\")\ndef getSelectedData():\n  keyboard.press_and_release(\"ctrl+c\")\n  time.sleep(0.5) \n  return str(pyperclip.paste())\ndef getClipboardData():\n  return str(pyperclip.paste())",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getCurrentDay",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getCurrentDay():\n  return datetime.now().strftime(\"%A\")\ndef getSelectedData():\n  keyboard.press_and_release(\"ctrl+c\")\n  time.sleep(0.5) \n  return str(pyperclip.paste())\ndef getClipboardData():\n  return str(pyperclip.paste())\ndef copyToClipboard(text):\n  pyperclip.copy(text)",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getSelectedData",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getSelectedData():\n  keyboard.press_and_release(\"ctrl+c\")\n  time.sleep(0.5) \n  return str(pyperclip.paste())\ndef getClipboardData():\n  return str(pyperclip.paste())\ndef copyToClipboard(text):\n  pyperclip.copy(text)\ndef Sleep():\n  if platform.system() == \"Windows\":",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getClipboardData",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getClipboardData():\n  return str(pyperclip.paste())\ndef copyToClipboard(text):\n  pyperclip.copy(text)\ndef Sleep():\n  if platform.system() == \"Windows\":\n    os.system(\"rundll32.exe powrprof.dll,SetSuspendState 0,1,0\")\n  elif platform.system() == \"Linux\":\n    os.system(\"systemctl suspend\")\n  elif platform.system() == \"Darwin\":  # macOS",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "copyToClipboard",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def copyToClipboard(text):\n  pyperclip.copy(text)\ndef Sleep():\n  if platform.system() == \"Windows\":\n    os.system(\"rundll32.exe powrprof.dll,SetSuspendState 0,1,0\")\n  elif platform.system() == \"Linux\":\n    os.system(\"systemctl suspend\")\n  elif platform.system() == \"Darwin\":  # macOS\n    os.system(\"pmset sleepnow\")\ndef Shutdown():",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "Sleep",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def Sleep():\n  if platform.system() == \"Windows\":\n    os.system(\"rundll32.exe powrprof.dll,SetSuspendState 0,1,0\")\n  elif platform.system() == \"Linux\":\n    os.system(\"systemctl suspend\")\n  elif platform.system() == \"Darwin\":  # macOS\n    os.system(\"pmset sleepnow\")\ndef Shutdown():\n  if platform.system() == \"Windows\":\n    os.system(\"shutdown /s /t 0\")",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "Shutdown",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def Shutdown():\n  if platform.system() == \"Windows\":\n    os.system(\"shutdown /s /t 0\")\n  elif platform.system() == \"Linux\":\n    os.system(\"shutdown now\")\n  elif platform.system() == \"Darwin\":  # macOS\n    os.system(\"sudo shutdown -h now\")\ndef Restart():\n  if platform.system() == \"Windows\":\n    os.system(\"shutdown /r /t 0\")",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "Restart",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def Restart():\n  if platform.system() == \"Windows\":\n    os.system(\"shutdown /r /t 0\")\n  elif platform.system() == \"Linux\":\n    os.system(\"reboot\")\n  elif platform.system() == \"Darwin\":  # macOS\n    os.system(\"sudo shutdown -r now\")\ndef Lock():\n  if platform.system() == \"Windows\":\n    ctypes.windll.user32.LockWorkStation()",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "Lock",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def Lock():\n  if platform.system() == \"Windows\":\n    ctypes.windll.user32.LockWorkStation()\n  elif platform.system() == \"Linux\":\n    os.system(\"gnome-screensaver-command -l\")\n  elif platform.system() == \"Darwin\":  # macOS\n    os.system(\"pmset displaysleepnow\")\ndef newMeeting():\n  webbrowser.open(\"https://meet.new\")\ndef wordRelations(word, relation_type):",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "newMeeting",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def newMeeting():\n  webbrowser.open(\"https://meet.new\")\ndef wordRelations(word, relation_type):\n  synsets = wordnet.synsets(word)\n  if relation_type == \"meaning\":\n    if synsets:\n      meanings = [synset.definition() for synset in synsets]\n      return ', '.join(meanings) if meanings else \"No meaning found\"\n    else:\n      return \"No meaning found\"",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "wordRelations",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def wordRelations(word, relation_type):\n  synsets = wordnet.synsets(word)\n  if relation_type == \"meaning\":\n    if synsets:\n      meanings = [synset.definition() for synset in synsets]\n      return ', '.join(meanings) if meanings else \"No meaning found\"\n    else:\n      return \"No meaning found\"\n  elif relation_type == \"synonym\":\n    if synsets:",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "writeViaKeyboard",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def writeViaKeyboard(text):\n  keyboard.write(text)\ndef voiceTyping():\n  a = Listen()\n  writeViaKeyboard(a)\ndef websiteScanner():\n  chrome_history_path = os.path.expanduser('~') + r\"\\AppData\\Local\\Google\\Chrome\\User Data\\Profile 1\\History\"\n  history_db_path = os.path.join(os.getcwd(), \"ChromeHistoryCopy.txt\")\n  shutil.copy2(chrome_history_path, history_db_path)\n  conn = sqlite3.connect(history_db_path)",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "voiceTyping",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def voiceTyping():\n  a = Listen()\n  writeViaKeyboard(a)\ndef websiteScanner():\n  chrome_history_path = os.path.expanduser('~') + r\"\\AppData\\Local\\Google\\Chrome\\User Data\\Profile 1\\History\"\n  history_db_path = os.path.join(os.getcwd(), \"ChromeHistoryCopy.txt\")\n  shutil.copy2(chrome_history_path, history_db_path)\n  conn = sqlite3.connect(history_db_path)\n  cursor = conn.cursor()\n  cursor.execute(\"SELECT url FROM urls ORDER BY last_visit_time DESC LIMIT 1\")",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "websiteScanner",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def websiteScanner():\n  chrome_history_path = os.path.expanduser('~') + r\"\\AppData\\Local\\Google\\Chrome\\User Data\\Profile 1\\History\"\n  history_db_path = os.path.join(os.getcwd(), \"ChromeHistoryCopy.txt\")\n  shutil.copy2(chrome_history_path, history_db_path)\n  conn = sqlite3.connect(history_db_path)\n  cursor = conn.cursor()\n  cursor.execute(\"SELECT url FROM urls ORDER BY last_visit_time DESC LIMIT 1\")\n  latest_url = cursor.fetchone()[0]\n  conn.close()\n  os.remove(history_db_path)",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "checkInternetSpeed",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def checkInternetSpeed():\n  st = speedtest.Speedtest()\n  download_speed = st.download() / 1_000_000  # Convert to Mbps\n  upload_speed = st.upload() / 1_000_000  # Convert to Mbps\n  return int(download_speed), int(upload_speed)\ndef getPublicIP():\n  ip = requests.get(\"https://api.ipify.org\").text\n  return ip\ndef getLocalIP():\n  hostname = socket.gethostname()",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getPublicIP",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getPublicIP():\n  ip = requests.get(\"https://api.ipify.org\").text\n  return ip\ndef getLocalIP():\n  hostname = socket.gethostname()\n  local_ip = socket.gethostbyname(hostname)\n  return local_ip\ndef searchWikipedia(query):\n  summary = wikipedia.summary(query, sentences=2)\n  return summary",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getLocalIP",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getLocalIP():\n  hostname = socket.gethostname()\n  local_ip = socket.gethostbyname(hostname)\n  return local_ip\ndef searchWikipedia(query):\n  summary = wikipedia.summary(query, sentences=2)\n  return summary\ndef getCryptoPrice(crypto=\"bitcoin\"):\n  url = f'https://api.coingecko.com/api/v3/simple/price?ids={crypto}&vs_currencies=usd'\n  response = requests.get(url)",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "searchWikipedia",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def searchWikipedia(query):\n  summary = wikipedia.summary(query, sentences=2)\n  return summary\ndef getCryptoPrice(crypto=\"bitcoin\"):\n  url = f'https://api.coingecko.com/api/v3/simple/price?ids={crypto}&vs_currencies=usd'\n  response = requests.get(url)\n  data = response.json()\n  return data[crypto]['usd']\ndef searchAndOpen(product_name):\n  product_name = urllib.parse.quote_plus(product_name)",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getCryptoPrice",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getCryptoPrice(crypto=\"bitcoin\"):\n  url = f'https://api.coingecko.com/api/v3/simple/price?ids={crypto}&vs_currencies=usd'\n  response = requests.get(url)\n  data = response.json()\n  return data[crypto]['usd']\ndef searchAndOpen(product_name):\n  product_name = urllib.parse.quote_plus(product_name)\n  webbrowser.open(f\"https://www.amazon.com/s?k={product_name}\")\n  webbrowser.open(f\"https://www.ebay.com/sch/i.html?_nkw={product_name}\")\n  webbrowser.open(f\"https://www.flipkart.com/search?q={product_name}\")",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "searchAndOpen",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def searchAndOpen(product_name):\n  product_name = urllib.parse.quote_plus(product_name)\n  webbrowser.open(f\"https://www.amazon.com/s?k={product_name}\")\n  webbrowser.open(f\"https://www.ebay.com/sch/i.html?_nkw={product_name}\")\n  webbrowser.open(f\"https://www.flipkart.com/search?q={product_name}\")\ndef textSummarisation(text):\n  model = genai.GenerativeModel('gemini-1.5-pro-latest')\n  responseAI = model.generate_content(f\"\"\"\n    {text}\n    QUERY : Given above is a piece of text.",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "textSummarisation",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def textSummarisation(text):\n  model = genai.GenerativeModel('gemini-1.5-pro-latest')\n  responseAI = model.generate_content(f\"\"\"\n    {text}\n    QUERY : Given above is a piece of text.\n    Summarize this text in a few words without omitting any key points of the text.\n  \"\"\")\n  return responseAI.text\ndef getNews():\n  news_str = \"\"",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "getNews",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def getNews():\n  news_str = \"\"\n  urls = []\n  url = (f'https://newsapi.org/v2/everything?'\n    f'q=india&' \n    f'from={(datetime.today() - timedelta(days=1)).strftime(\"%Y-%m-%d\")}&' \n    f'to={datetime.today()}&' \n    f'sortBy=popularity&' \n    f'language=en&' \n    f'apiKey={news_api}'",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "toastNotification",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def toastNotification(app_id, title, msg, duration, icon, loop):\n  toast = Notification(app_id=app_id, title=title, msg=msg, duration=duration, icon=icon)\n  if loop:\n    toast.set_audio(audio.LoopingCall, loop=True)\n  else:\n    toast.set_audio(audio.Default, loop=False)\n  toast.show()\n################### NOT TO BE USED BY GEMINI #######################\ndef __IM_getCurrentTime():\n  current_time = datetime.now()",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "TDL_activate",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def TDL_activate():\n  global TDL_ACTIVE\n  TDL_ACTIVE = True\n  def daemonTask():\n    while TDL_ACTIVE:\n      print(\"Checking for tasks...\")\n      __UpdateTasks()\n      to_delete = []\n      for task in tasks:\n        if task.split(' ')[0] == __IM_getCurrentTime():",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "TDL_deactivate",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def TDL_deactivate():\n  global TDL_ACTIVE\n  TDL_ACTIVE = False\ndef TDL_show():\n  os.system(f\"notepad.exe {os.getcwd()}/todolist.txt\")\n###################################################################\nif __name__ == \"__main__\":\n  TDL_activate()\n#   TDL_show()\n#   while True:",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "TDL_show",
        "kind": 2,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "def TDL_show():\n  os.system(f\"notepad.exe {os.getcwd()}/todolist.txt\")\n###################################################################\nif __name__ == \"__main__\":\n  TDL_activate()\n#   TDL_show()\n#   while True:\n#     pass",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "TDL_ACTIVE",
        "kind": 5,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "TDL_ACTIVE = False\ntasks = []\ndef TDL_activate():\n  global TDL_ACTIVE\n  TDL_ACTIVE = True\n  def daemonTask():\n    while TDL_ACTIVE:\n      print(\"Checking for tasks...\")\n      __UpdateTasks()\n      to_delete = []",
        "detail": "Skills",
        "documentation": {}
    },
    {
        "label": "tasks",
        "kind": 5,
        "importPath": "Skills",
        "description": "Skills",
        "peekOfCode": "tasks = []\ndef TDL_activate():\n  global TDL_ACTIVE\n  TDL_ACTIVE = True\n  def daemonTask():\n    while TDL_ACTIVE:\n      print(\"Checking for tasks...\")\n      __UpdateTasks()\n      to_delete = []\n      for task in tasks:",
        "detail": "Skills",
        "documentation": {}
    }
]